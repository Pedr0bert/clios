======================================================================================
 CLIOS SHELL - CÃ“DIGO COMPLETO v1.0.0
 Desenvolvido em Rust
 Todos os mÃ³dulos compilados em um Ãºnico arquivo
 Data de geraÃ§Ã£o: $(date +"%Y-%m-%d %H:%M:%S")
======================================================================================


// =====================================================================================
// src/main.rs
// =====================================================================================

//! # Clios Shell (Command Line Interface & Operating System Shell)
//!
//! Bem-vindo Ã  documentaÃ§Ã£o oficial da **Clios**, uma shell hÃ­brida desenvolvida em Rust.
//!
//! ## Funcionalidades Principais:
//! * **Interatividade:** Prompt rico com histÃ³rico e autocomplete (via `rustyline`).
//! * **Scripting:** Suporte nativo Ã  linguagem Rhai para scripts complexos.
//! * **Job Control:** Gerenciamento de processos Unix (bg, fg, signals) via `nix`.
//! * **Parsing:** Suporte a pipes `|`, redirecionamento `>` e lÃ³gica `&&`.
//!
//! ##  Como Usar
//!
//! ```bash
//! # Modo Interativo
//! clios
//!
//! # Executar Script
//! clios script.rhai
//!
//! # Comando Ãšnico
//! clios -c "echo Hello World"
//! ```

// --- MODULE DECLARATIONS ---
mod builtins;
mod completion;
mod config;
mod expansion;
mod jobs;
mod pipeline;
mod prompt;
mod rhai_integration;
mod shell;

#[cfg(test)]
mod tests;

// --- IMPORTS ---
use completion::CliosHelper;
use config::{get_color_ansi, load_toml_config};
use prompt::{build_powerline_prompt, get_git_branch, get_powerline_segments};
use rhai_integration::run_rhai_script;
use shell::CliosShell;

use rustyline::error::ReadlineError;
use rustyline::history::DefaultHistory;
use rustyline::Editor;
use std::env;
use std::fs::File;
use std::io::{BufRead, BufReader};
use std::path::Path;

// -----------------------------------------------------------------------------
// MAIN FUNCTION
// -----------------------------------------------------------------------------

fn main() -> rustyline::Result<()> {
    // 1. Load configuration
    let loaded_config = load_toml_config();

    // 2. Initialize the Shell
    let mut shell = CliosShell::new(loaded_config);

    // Load auto-plugins from ~/.clios_plugins
    shell.load_auto_plugins();

    // Load user config from ~/.cliosrc
    shell.load_config();

    // --- COMMAND LINE ARGUMENTS ---
    let args: Vec<String> = env::args().collect();

    if args.len() > 1 {
        // CASE A: Flag -c (Single command)
        if args[1] == "-c" {
            if args.len() > 2 {
                let command = &args[2];
                let _ = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
                    shell.process_input_line(command);
                }));
            } else {
                eprintln!("Erro: -c requer um comando entre aspas");
                std::process::exit(1);
            }
            return Ok(());
        }

        // CASE B: Rhai Script (.rhai)
        if args[1].ends_with(".rhai") {
            println!("--- Executando Script Rhai ---");
            if let Err(e) = run_rhai_script(&args[1]) {
                eprintln!("Erro no script Rhai: {}", e);
                std::process::exit(1);
            }
            return Ok(());
        }

        // CASE C: Shell Script
        let script_path = Path::new(&args[1]);
        if let Ok(file) = File::open(script_path) {
            let reader = BufReader::new(file);
            for line in reader.lines() {
                if let Ok(l) = line
                    && !l.trim().is_empty() && !l.starts_with('#') {
                        let _ = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
                            shell.process_input_line(&l);
                        }));
                    }
            }
            return Ok(());
        } else {
            eprintln!("Erro: Arquivo nÃ£o encontrado '{}'", args[1]);
            std::process::exit(1);
        }
    }

    // --- INTERACTIVE MODE ---

    // Extract history configuration
    let (hist_file, max_entries) = if let Some(h) = &shell.config.history {
        (
            h.file.as_deref().unwrap_or(".clios_history"),
            h.max_entries.unwrap_or(1000),
        )
    } else {
        (".clios_history", 1000)
    };

    // Configure Rustyline
    let config = rustyline::Config::builder()
        .auto_add_history(false)
        .max_history_size(max_entries)
        .unwrap()
        .build();

    // Get syntax highlighting colors
    let (valid_str, invalid_str) = if let Some(syntax) = &shell.config.syntax {
        (
            syntax.valid_cmd.as_deref().unwrap_or("green"),
            syntax.invalid_cmd.as_deref().unwrap_or("red"),
        )
    } else {
        ("green", "red")
    };

    // Create the helper
    let h = CliosHelper::new(get_color_ansi(valid_str), get_color_ansi(invalid_str));

    // Initialize the Editor
    let mut rl: Editor<CliosHelper, DefaultHistory> = Editor::with_config(config)?;
    rl.set_helper(Some(h));

    // History path
    let history_path = env::var("HOME")
        .map(|p| Path::new(&p).join(hist_file))
        .unwrap_or_else(|_| Path::new(hist_file).to_path_buf());

    // Load history
    if rl.load_history(&history_path).is_err() {
        println!("Bem-vindo ao Clios Shell v1.0 (Final Release) ");
        println!("Digite 'create' para iniciar um projeto ou 'rhai' para scripts.");
    }

    // Theme control
    let mut current_theme = shell
        .config
        .theme
        .clone()
        .unwrap_or_else(|| "powerline".to_string());

    // --- MAIN LOOP (REPL) ---
    loop {
        let final_prompt = if current_theme == "powerline" {
            // Powerline mode
            let segments = get_powerline_segments(&shell.config);
            let prompt_bar = build_powerline_prompt(segments);
            format!("{} \x1b[1;32mâ¯\x1b[0m ", prompt_bar)
        } else {
            // Classic mode
            build_classic_prompt(&shell)
        };

        // Inject prompt into Rustyline
        if let Some(helper) = rl.helper_mut() {
            helper.colored_prompt = final_prompt.clone();
        }

        match rl.readline(&final_prompt) {
            Ok(line) => {
                let input = line.trim();
                if input.is_empty() {
                    continue;
                }

                // Theme switching commands
                if input == "theme classic" {
                    current_theme = "classic".to_string();
                    continue;
                }
                if input == "theme powerline" {
                    current_theme = "powerline".to_string();
                    continue;
                }

                // Save to history
                let _ = rl.add_history_entry(input);
                let _ = rl.append_history(&history_path);

                // Execute
                let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
                    shell.process_input_line(input);
                }));
                if result.is_err() {
                    eprintln!("\n(!) Panic recuperado.");
                }
            }
            Err(ReadlineError::Interrupted) => {
                println!("CTRL-C");
                continue;
            }
            Err(ReadlineError::Eof) => {
                break;
            }
            Err(_) => {
                break;
            }
        }
    }

    // Save history on exit
    rl.save_history(&history_path)?;
    Ok(())
}

// -----------------------------------------------------------------------------
// HELPER FUNCTIONS
// -----------------------------------------------------------------------------

/// Builds the classic (customizable) prompt.
fn build_classic_prompt(shell: &CliosShell) -> String {
    let current_dir = env::current_dir().unwrap_or_default();
    let dir_display = current_dir.display();

    let (symbol, default_color, path_color_cfg, symbol_color_cfg, show_git) =
        if let Some(p) = &shell.config.prompt {
            (
                p.symbol.as_deref().unwrap_or(">"),
                p.color.as_deref().unwrap_or("blue"),
                p.path_color.as_deref(),
                p.symbol_color.as_deref(),
                p.show_git.unwrap_or(true),
            )
        } else {
            (">", "blue", None, None, true)
        };

    let path_ansi = get_color_ansi(path_color_cfg.unwrap_or(default_color));
    let arrow_ansi = get_color_ansi(symbol_color_cfg.unwrap_or(default_color));

    let git_color = if show_git {
        if let Some(branch) = get_git_branch() {
            format!(" (\x1b[1;35m{}\x1b[0m)", branch)
        } else {
            String::new()
        }
    } else {
        String::new()
    };

    let arrow_colored = if shell.last_exit_code == 0 {
        format!("{}{}\x1b[0m ", arrow_ansi, symbol)
    } else {
        format!("\x1b[1;31m[{}]>\x1b[0m ", shell.last_exit_code)
    };

    format!(
        "{}{}:{}{}\x1b[0m{}",
        path_ansi, "clios", dir_display, git_color, arrow_colored
    )
}


// =====================================================================================
// src/config.rs
// =====================================================================================

//! # Configuration Module
//!
//! Handles loading and parsing of the `~/.clios.toml` configuration file.
//! Also defines all configuration structures used throughout the shell.

use serde::Deserialize;
use std::env;
use std::path::Path;

// -----------------------------------------------------------------------------
// PROMPT CONFIGURATION
// -----------------------------------------------------------------------------

/// ConfiguraÃ§Ãµes visuais do Prompt de comando.
///
/// Esta estrutura mapeia a seÃ§Ã£o `[prompt]` do arquivo de configuraÃ§Ã£o `.clios.toml`.
/// Permite que o usuÃ¡rio personalize cores, sÃ­mbolos e informaÃ§Ãµes exibidas.
#[derive(Debug, Deserialize, Clone)]
pub struct ConfigPrompt {
    /// O sÃ­mbolo exibido no final do prompt (ex: `>`, `$`, `âœ`, ``).
    /// * PadrÃ£o: `>`
    pub symbol: Option<String>,

    /// A cor do sÃ­mbolo e do separador.
    /// * Valores aceitos: "red", "green", "blue", "purple", "cyan", "yellow".
    /// * PadrÃ£o: "blue"
    pub color: Option<String>,

    /// Cor do caminho (/mnt/c/...)
    pub path_color: Option<String>,

    /// Cor do sÃ­mbolo (setinha >)
    pub symbol_color: Option<String>,

    /// Define se deve mostrar a branch atual do Git.
    /// * PadrÃ£o: `true`
    pub show_git: Option<bool>,
}

// -----------------------------------------------------------------------------
// HISTORY CONFIGURATION
// -----------------------------------------------------------------------------

/// ConfiguraÃ§Ãµes do histÃ³rico de comandos.
///
/// Esta estrutura mapeia a seÃ§Ã£o `[history]` do arquivo `.clios.toml`.
#[derive(Debug, Deserialize, Clone)]
pub struct ConfigHistory {
    /// Nome do arquivo onde o histÃ³rico serÃ¡ salvo na pasta HOME.
    /// * PadrÃ£o: `.clios_history`
    pub file: Option<String>,

    /// NÃºmero mÃ¡ximo de comandos a serem lembrados.
    /// * PadrÃ£o: `1000`
    pub max_entries: Option<usize>,
}

// -----------------------------------------------------------------------------
// SYNTAX HIGHLIGHTING CONFIGURATION
// -----------------------------------------------------------------------------

/// ConfiguraÃ§Ãµes de cores para o realce de sintaxe (Syntax Highlighting).
///
/// Mapeia a seÃ§Ã£o `[syntax]` do arquivo `.clios.toml`.
/// Define as cores usadas enquanto o usuÃ¡rio digita um comando.
#[derive(Debug, Deserialize, Clone)]
pub struct ConfigSyntax {
    /// Cor para comandos vÃ¡lidos (encontrados no sistema ou builtins).
    /// * PadrÃ£o: "green"
    pub valid_cmd: Option<String>,

    /// Cor para comandos invÃ¡lidos (nÃ£o encontrados).
    /// * PadrÃ£o: "red"
    pub invalid_cmd: Option<String>,
}

// -----------------------------------------------------------------------------
// VERSION READING STRUCTURES
// -----------------------------------------------------------------------------

/// Struct para ler Cargo.toml
#[derive(Deserialize)]
pub struct CargoToml {
    pub package: CargoPackage,
}

#[derive(Deserialize)]
pub struct CargoPackage {
    pub version: String,
}

/// Struct para ler package.json
#[derive(Deserialize)]
pub struct PackageJson {
    pub version: String,
}

/// Struct para ler pyproject.toml
#[derive(Deserialize)]
pub struct PyProjectToml {
    pub project: Option<PyProjectSection>,
    pub tool: Option<PyToolSection>,
}

#[derive(Deserialize)]
pub struct PyProjectSection {
    pub version: Option<String>,
}

#[derive(Deserialize)]
pub struct PyToolSection {
    pub poetry: Option<PyPoetrySection>,
}

#[derive(Deserialize)]
pub struct PyPoetrySection {
    pub version: Option<String>,
}

// -----------------------------------------------------------------------------
// ROOT CONFIGURATION
// -----------------------------------------------------------------------------

/// A ConfiguraÃ§Ã£o Raiz (Root) da Clios Shell.
///
/// Esta Ã© a estrutura principal que representa o arquivo `~/.clios.toml` inteiro.
/// O `serde` lÃª o arquivo e preenche estes campos automaticamente.
///
/// # Exemplo de Arquivo `.clios.toml`
/// ```toml
/// [prompt]
/// symbol = "âœ"
/// color = "purple"
///
/// [history]
/// max_entries = 5000
/// ```
#[derive(Debug, Deserialize, Clone)]
pub struct CliosConfig {
    /// ConfiguraÃ§Ãµes da seÃ§Ã£o `[prompt]`.
    pub prompt: Option<ConfigPrompt>,

    /// ConfiguraÃ§Ãµes da seÃ§Ã£o `[history]`.
    pub history: Option<ConfigHistory>,

    /// ConfiguraÃ§Ãµes da seÃ§Ã£o `[syntax]`.
    pub syntax: Option<ConfigSyntax>,

    /// Tema do prompt (powerline ou classic).
    pub theme: Option<String>,
}

impl CliosConfig {
    /// Retorna a configuraÃ§Ã£o padrÃ£o (Default) caso o arquivo nÃ£o exista.
    ///
    /// # Valores PadrÃ£o
    /// * **Prompt:** SÃ­mbolo `> `, Cor `blue`, Git `true`.
    /// * **History:** Arquivo `.clios_history`, 1000 entradas.
    pub fn default() -> Self {
        Self {
            prompt: Some(ConfigPrompt {
                symbol: Some("> ".to_string()),
                color: Some("blue".to_string()),
                show_git: Some(true),
                path_color: None,
                symbol_color: None,
            }),
            history: Some(ConfigHistory {
                file: Some(".clios_history".to_string()),
                max_entries: Some(1000),
            }),
            syntax: Some(ConfigSyntax {
                valid_cmd: Some("green".to_string()),
                invalid_cmd: Some("red".to_string()),
            }),
            theme: Some("powerline".to_string()),
        }
    }
}

// -----------------------------------------------------------------------------
// LOADING FUNCTIONS
// -----------------------------------------------------------------------------

/// Carrega a configuraÃ§Ã£o do usuÃ¡rio a partir de um arquivo TOML.
///
/// # EstratÃ©gia de Carregamento
/// 1. Busca pela variÃ¡vel de ambiente `$HOME`.
/// 2. Tenta abrir o arquivo `$HOME/.clios.toml`.
/// 3. Se o arquivo existir e for vÃ¡lido, retorna a `CliosConfig` preenchida.
/// 4. Se o arquivo nÃ£o existir ou tiver erros de sintaxe, retorna `CliosConfig::default()`
///    e imprime um aviso no stderr (se for erro de sintaxe).
pub fn load_toml_config() -> CliosConfig {
    // 1. ConstrÃ³i o caminho ~/.clios.toml
    let config_path = env::var("HOME")
        .map(|p| Path::new(&p).join(".clios.toml"))
        .unwrap_or_else(|_| Path::new(".clios.toml").to_path_buf());

    // 2. Tenta ler e fazer o parse
    if config_path.exists()
        && let Ok(contents) = std::fs::read_to_string(&config_path) {
            match toml::from_str::<CliosConfig>(&contents) {
                Ok(cfg) => return cfg, // Sucesso!
                Err(e) => {
                    eprintln!(
                        "\x1b[1;33m[AVISO CONFIG]\x1b[0m Erro no .clios.toml: {}",
                        e
                    );
                    eprintln!("--> Usando configuraÃ§Ã£o padrÃ£o.");
                }
            }
        }

    // 3. Fallback para padrÃ£o
    CliosConfig::default()
}

/// Converte um nome de cor legÃ­vel (ex: "red") para seu cÃ³digo ANSI correspondente.
///
/// Esta funÃ§Ã£o Ã© usada para traduzir as configuraÃ§Ãµes do usuÃ¡rio no arquivo TOML
/// para os caracteres de escape que o terminal entende.
///
/// # Cores Suportadas
/// * red, green, yellow, blue, purple, cyan, white.
/// * Qualquer outra string retorna o cÃ³digo de reset/padrÃ£o.
pub fn get_color_ansi(color_name: &str) -> String {
    match color_name {
        "red" => "\x1b[31m".to_string(),
        "green" => "\x1b[32m".to_string(),
        "yellow" => "\x1b[33m".to_string(),
        "blue" => "\x1b[34m".to_string(),
        "purple" => "\x1b[35m".to_string(),
        "cyan" => "\x1b[36m".to_string(),
        "white" => "\x1b[37m".to_string(),
        _ => "\x1b[0m".to_string(), // Default (sem cor)
    }
}


// =====================================================================================
// src/shell.rs
// =====================================================================================

//! # Shell Module
//!
//! Contains the main CliosShell struct and core shell logic.
//!
//! ## Responsabilidades
//! - Manter o estado global da sessÃ£o
//! - Processar linhas de entrada
//! - Gerenciar aliases e plugins
//! - Coordenar expansÃµes e execuÃ§Ã£o de comandos

use crate::builtins::{handle_builtin, BuiltinResult};
use crate::config::CliosConfig;
use crate::expansion::{
    expand_alias_string, expand_globs, expand_subshells, expand_tilde, expand_variables,
    split_logical_and,
};
use crate::jobs::execute_job_control;
use crate::pipeline::execute_pipeline;
use crate::rhai_integration::{create_rhai_engine, try_execute_plugin_function};

use rhai::{Engine, Scope, AST};
use std::collections::HashMap;
use std::env;
use std::fs::{self, File};
use std::io::{BufRead, BufReader};
use std::path::{Path, PathBuf};

// -----------------------------------------------------------------------------
// HELPER FUNCTIONS
// -----------------------------------------------------------------------------

/// Divide uma string por pipes (|) respeitando aspas.
/// 
/// Esta funÃ§Ã£o percorre a string caractere por caractere e sÃ³ divide por |
/// quando nÃ£o estÃ¡ dentro de aspas simples ou duplas.
fn split_pipes_respecting_quotes(input: &str) -> Vec<String> {
    let mut parts = Vec::new();
    let mut current = String::new();
    let mut in_single_quote = false;
    let mut in_double_quote = false;
    let chars = input.chars().peekable();

    for c in chars {
        match c {
            '\'' if !in_double_quote => {
                in_single_quote = !in_single_quote;
                current.push(c);
            }
            '"' if !in_single_quote => {
                in_double_quote = !in_double_quote;
                current.push(c);
            }
            '|' if !in_single_quote && !in_double_quote => {
                parts.push(current.clone());
                current.clear();
            }
            _ => current.push(c),
        }
    }

    // Adiciona a Ãºltima parte
    if !current.is_empty() {
        parts.push(current);
    }

    // Se nÃ£o encontrou nenhum pipe ou se parts estÃ¡ vazio, retorna input
    if parts.is_empty() {
        vec![input.to_string()]
    } else {
        parts
    }
}

// -----------------------------------------------------------------------------
// CLIOS SHELL STRUCT
// -----------------------------------------------------------------------------

/// # CliosShell (O CoraÃ§Ã£o LÃ³gico)
///
/// Esta estrutura mantÃ©m o **Estado Global** da sessÃ£o da shell.
/// Diferente do Helper (que cuida da tela), aqui ficam os dados que precisam
/// persistir entre um comando e outro.
pub struct CliosShell {
    /// Mapa de apelidos (Aliases). Ex: "update" -> "sudo apt update".
    pub aliases: HashMap<String, String>,

    /// O Motor (Engine) da linguagem de script Rhai.
    pub rhai_engine: Engine,

    /// O Escopo (Scope) da linguagem Rhai.
    pub rhai_scope: Scope<'static>,

    /// O CÃ³digo de SaÃ­da (Exit Code) do Ãºltimo comando executado.
    pub last_exit_code: i32,

    /// Armazena o caminho do diretÃ³rio anterior.
    pub previous_dir: Option<PathBuf>,

    /// ConfiguraÃ§Ãµes carregadas do arquivo TOML.
    pub config: CliosConfig,

    /// AST do script de inicializaÃ§Ã£o (se houver).
    pub plugin_ast: Option<AST>,
}

impl CliosShell {
    /// Construtor: Inicializa a Shell e configura o motor de Script (Rhai).
    pub fn new(config: CliosConfig) -> Self {
        let engine = create_rhai_engine();

        Self {
            aliases: HashMap::new(),
            rhai_engine: engine,
            rhai_scope: Scope::new(),
            plugin_ast: None,
            last_exit_code: 0,
            previous_dir: None,
            config,
        }
    }

    /// NÃVEL 12: Carregador de Plugins (CompilaÃ§Ã£o Ãšnica)
    pub fn load_plugin(&mut self, path: &str) {
        // Verificar se o arquivo existe
        if !std::path::Path::new(path).exists() {
            eprintln!("\x1b[1;31m[ERRO PLUGIN]\x1b[0m Arquivo nÃ£o encontrado: {}", path);
            return;
        }

        match self.rhai_engine.compile_file(path.into()) {
            Ok(new_ast) => {
                if let Some(ref mut existing_ast) = self.plugin_ast {
                    *existing_ast += new_ast;
                } else {
                    self.plugin_ast = Some(new_ast);
                }
                // Sucesso silencioso - apenas erros sÃ£o exibidos
            }
            Err(e) => {
                eprintln!("\x1b[1;31m[ERRO PLUGIN]\x1b[0m Falha ao compilar '{}'", path);
                eprintln!("  Detalhes: {}", e);
            }
        }
    }

    /// NÃVEL 17: Auto-Loader de Plugins
    pub fn load_auto_plugins(&mut self) {
        let home = env::var("HOME").unwrap_or_else(|_| ".".to_string());
        let plugins_dir = Path::new(&home).join(".clios_plugins");

        if let Ok(entries) = fs::read_dir(plugins_dir) {
            for entry in entries.flatten() {
                let path = entry.path();

                if path.is_file() && path.extension().and_then(|s| s.to_str()) == Some("rhai")
                    && let Some(path_str) = path.to_str() {
                        self.load_plugin(path_str);
                    }
            }
        }
    }

    /// LÃª o arquivo de configuraÃ§Ã£o `~/.cliosrc` e executa linha por linha.
    pub fn load_config(&mut self) {
        if let Ok(home) = env::var("HOME") {
            let config_path = Path::new(&home).join(".cliosrc");
            if config_path.exists()
                && let Ok(file) = File::open(config_path) {
                    let reader = BufReader::new(file);

                    for (i, line) in reader.lines().enumerate() {
                        if let Ok(l) = line {
                            let l = l.trim();

                            if !l.is_empty() && !l.starts_with('#') {
                                if shlex::split(l).is_none() {
                                    eprintln!(
                                        "\x1b[1;31m[ERRO CONFIG]\x1b[0m .cliosrc Linha {}: Aspas nÃ£o fechadas.",
                                        i + 1
                                    );
                                    eprintln!("--> ConteÃºdo: {}", l);
                                    continue;
                                }

                                self.process_input_line(l);
                            }
                        }
                    }
                }
        }
    }

    /// O CÃ©rebro da ExecuÃ§Ã£o: Processa uma linha de entrada bruta.
    pub fn process_input_line(&mut self, input: &str) {
        let input_expanded = expand_subshells(input);

        let logical_parts = split_logical_and(&input_expanded);

        for part in logical_parts {
            let expanded_part = expand_alias_string(&part, &self.aliases);

            if expanded_part != part && expanded_part.contains("&&") {
                self.process_input_line(&expanded_part);

                if self.last_exit_code != 0 {
                    break;
                }
                continue;
            }

            let exit_code = self.execute_single_command_block(&expanded_part);
            self.last_exit_code = exit_code;

            if exit_code != 0 {
                break;
            }
        }
    }

    /// Executa um bloco de comando Ãºnico (sem &&, mas pode ter Pipes |).
    fn execute_single_command_block(&mut self, input: &str) -> i32 {
        // ValidaÃ§Ã£o: entrada vazia ou sÃ³ espaÃ§os
        if input.trim().is_empty() {
            return 0;
        }

        let commands_raw = split_pipes_respecting_quotes(input);

        if commands_raw.len() == 1 {
            let raw_line = commands_raw[0].trim();

            let background = raw_line.ends_with('&');
            let clean_line = if background {
                raw_line[..raw_line.len() - 1].trim()
            } else {
                raw_line
            };

            let mut tokens = match shlex::split(clean_line) {
                Some(t) => t,
                None => {
                    eprintln!(
                        "\x1b[1;31m[ERRO SINTAXE]\x1b[0m Falha ao processar: '{}'",
                        clean_line
                    );
                    return 1;
                }
            };

            // Tratamento Rhai
            if tokens.first().map(|s| s.as_str()) == Some("rhai")
                && let Some(idx) = clean_line.find("rhai") {
                    let code_part = clean_line[idx + 4..].trim();
                    tokens = vec!["rhai".to_string(), code_part.to_string()];
                }

            // ExpansÃµes finais
            if tokens.first().map(|s| s.as_str()) != Some("rhai") {
                tokens = expand_variables(tokens);
                tokens = expand_tilde(tokens);
                tokens = expand_globs(tokens);
            }

            if tokens.is_empty() {
                return 0;
            }

            let cmd_name = tokens[0].clone();
            let args = tokens[1..].to_vec();

            // 1. Tenta Plugin
            if let Some(ast) = &self.plugin_ast
                && try_execute_plugin_function(
                    &self.rhai_engine,
                    &mut self.rhai_scope,
                    ast,
                    &cmd_name,
                    args.clone(),
                ) {
                    return 0;
                }

            // 2. Tenta Builtin
            let result = handle_builtin(
                &tokens,
                &mut self.aliases,
                &mut self.previous_dir,
                &mut self.rhai_engine,
                &mut self.rhai_scope,
                &mut self.plugin_ast,
                |engine, ast, path| {
                    match engine.compile_file(path.into()) {
                        Ok(new_ast) => {
                            if let Some(existing_ast) = ast {
                                *existing_ast += new_ast;
                            } else {
                                *ast = Some(new_ast);
                            }
                        }
                        Err(e) => eprintln!("Erro ao compilar plugin: {}", e),
                    }
                },
            );

            match result {
                BuiltinResult::Handled => return 0,
                BuiltinResult::Exit => std::process::exit(0),
                BuiltinResult::NotBuiltin => {}
            }

            // 3. Executa como programa externo
            if background {
                execute_job_control(tokens, true);
                0
            } else {
                execute_pipeline(vec![tokens])
            }
        } else {
            // Pipeline
            let mut parsed_commands = Vec::new();

            for raw_cmd in commands_raw {
                let expanded_cmd = expand_alias_string(&raw_cmd, &self.aliases);
                let trimmed = expanded_cmd.trim();
                
                if trimmed.is_empty() {
                    continue;
                }

                // Tenta shlex primeiro, se falhar usa split simples por espaÃ§os
                let tokens = match shlex::split(trimmed) {
                    Some(t) if !t.is_empty() => t,
                    _ => {
                        // Fallback: split simples por espaÃ§os em branco
                        trimmed
                            .split_whitespace()
                            .map(|s| s.to_string())
                            .collect()
                    }
                };

                if tokens.is_empty() {
                    continue;
                }

                let tokens = expand_variables(tokens);
                let tokens = expand_tilde(tokens);
                let tokens = expand_globs(tokens);

                parsed_commands.push(tokens);
            }
            
            if parsed_commands.is_empty() {
                return 0;
            }
            
            execute_pipeline(parsed_commands)
        }
    }
}


// =====================================================================================
// src/builtins.rs
// =====================================================================================

//! # Builtins Module
//!
//! Contains all built-in shell commands that are executed internally
//! rather than spawning external processes.
//!
//! ## Comandos Suportados
//! - `cd` - Navegar entre diretÃ³rios
//! - `pwd` - Exibir diretÃ³rio atual
//! - `alias` - Gerenciar aliases
//! - `export` - Definir variÃ¡veis de ambiente
//! - `history` - Exibir histÃ³rico de comandos
//! - `source/load` - Carregar plugins Rhai
//! - `plugins` - Listar plugins carregados
//! - `rhai` - Executar cÃ³digo Rhai
//! - `fg` - Trazer processo para foreground
//! - `exit` - Sair da shell

use nix::sys::signal::{self, Signal};
use nix::sys::wait::{self, WaitPidFlag};
use nix::unistd::{self, Pid};
use rhai::{Engine, Scope, AST};
use std::collections::HashMap;
use std::env;
use std::fs::File;
use std::io::{BufRead, BufReader};
use std::path::PathBuf;

// -----------------------------------------------------------------------------
// BUILTIN EXECUTION
// -----------------------------------------------------------------------------

/// Resultado da execuÃ§Ã£o de um builtin.
pub enum BuiltinResult {
    /// O comando foi tratado como builtin.
    Handled,
    /// O comando nÃ£o era um builtin.
    NotBuiltin,
    /// O shell deve sair.
    Exit,
}

/// Executa comandos internos da Shell (Builtins).
/// Retorna o resultado da execuÃ§Ã£o.
#[allow(clippy::too_many_arguments)]
pub fn handle_builtin(
    tokens: &[String],
    aliases: &mut HashMap<String, String>,
    previous_dir: &mut Option<PathBuf>,
    rhai_engine: &mut Engine,
    rhai_scope: &mut Scope,
    plugin_ast: &mut Option<AST>,
    load_plugin_fn: impl Fn(&mut Engine, &mut Option<AST>, &str),
) -> BuiltinResult {
    if tokens.is_empty() {
        return BuiltinResult::NotBuiltin;
    }

    match tokens[0].as_str() {
        "cd" => {
            handle_cd(tokens, previous_dir);
            BuiltinResult::Handled
        }
        "history" => {
            handle_history();
            BuiltinResult::Handled
        }
        "source" | "load" => {
            if let Some(path) = tokens.get(1) {
                load_plugin_fn(rhai_engine, plugin_ast, path);
            } else {
                println!("Uso: source <arquivo.rhai>");
            }
            BuiltinResult::Handled
        }
        "plugins" => {
            handle_plugins(plugin_ast);
            BuiltinResult::Handled
        }
        "pwd" => {
            if let Ok(path) = env::current_dir() {
                println!("{}", path.display());
            }
            BuiltinResult::Handled
        }
        "exit" => BuiltinResult::Exit,
        "alias" => {
            handle_alias(tokens, aliases);
            BuiltinResult::Handled
        }
        "rhai" => {
            handle_rhai_command(tokens, rhai_engine, rhai_scope, plugin_ast);
            BuiltinResult::Handled
        }
        "fg" => {
            handle_fg(tokens);
            BuiltinResult::Handled
        }
        "export" => {
            handle_export(tokens);
            BuiltinResult::Handled
        }
        "unalias" => {
            handle_unalias(tokens, aliases);
            BuiltinResult::Handled
        }
        "unset" => {
            handle_unset(tokens);
            BuiltinResult::Handled
        }
        "type" => {
            handle_type(tokens, aliases);
            BuiltinResult::Handled
        }
        "help" => {
            handle_help();
            BuiltinResult::Handled
        }
        "version" => {
            println!("Clios Shell v1.0.0 (Final Release)");
            println!("Desenvolvido em Rust ğŸ¦€");
            BuiltinResult::Handled
        }
        _ => BuiltinResult::NotBuiltin,
    }
}

// -----------------------------------------------------------------------------
// INDIVIDUAL BUILTIN HANDLERS
// -----------------------------------------------------------------------------

/// Handles the `cd` command.
fn handle_cd(tokens: &[String], previous_dir: &mut Option<PathBuf>) {
    let target = if let Some(arg) = tokens.get(1) {
        if arg == "-" {
            if let Some(prev) = previous_dir {
                println!("{}", prev.display());
                Some(prev.clone())
            } else {
                println!("Erro: Nenhuma pasta anterior definida");
                None
            }
        } else {
            Some(PathBuf::from(arg))
        }
    } else {
        env::var("HOME").ok().map(PathBuf::from)
    };

    if let Some(new_dir) = target {
        if let Ok(current) = env::current_dir() {
            *previous_dir = Some(current);
        }

        if let Err(e) = env::set_current_dir(&new_dir) {
            eprintln!("cd: {}", e);
        }
    }
}

/// Handles the `history` command.
fn handle_history() {
    if let Ok(file) = File::open("history.txt") {
        let reader = BufReader::new(file);
        for (i, line) in reader.lines().enumerate() {
            if let Ok(l) = line {
                println!("{:5}  {}", i + 1, l);
            }
        }
    }
}

/// Handles the `plugins` command.
fn handle_plugins(plugin_ast: &Option<AST>) {
    if let Some(ast) = plugin_ast {
        println!("Comandos de Plugins Ativos:");
        println!("----------------------------");

        for func in ast.iter_functions() {
            if !func.name.starts_with('_') {
                println!("  âœ {} ({} args)", func.name, func.params.len());
            }
        }
        println!("----------------------------");
    } else {
        println!("Nenhum plugin carregado na memÃ³ria.");
    }
}

/// Handles the `alias` command.
fn handle_alias(tokens: &[String], aliases: &mut HashMap<String, String>) {
    if tokens.len() < 2 {
        for (name, val) in aliases.iter() {
            println!("{}='{}'", name, val);
        }
    } else {
        let arg = tokens[1..].join(" ");
        if let Some((name, value)) = arg.split_once('=') {
            aliases.insert(name.to_string(), value.to_string());
        } else {
            println!("Erro: Use alias nome=valor");
        }
    }
}

/// Handles the `rhai` command.
fn handle_rhai_command(tokens: &[String], rhai_engine: &mut Engine, rhai_scope: &mut Scope, plugin_ast: &Option<AST>) {
    let code = tokens.get(1).map(|s| s.as_str()).unwrap_or("").trim();

    if code.is_empty() {
        // Modo REPL
        run_rhai_repl(rhai_engine, rhai_scope, plugin_ast);
    } else {
        // ExecuÃ§Ã£o One-Shot - combina com funÃ§Ãµes do plugin se disponÃ­vel
        let result = if let Some(ast) = plugin_ast {
            // Compila o cÃ³digo do usuÃ¡rio e combina com o AST do plugin
            match rhai_engine.compile(code) {
                Ok(user_ast) => {
                    let combined = ast.clone().merge(&user_ast);
                    rhai_engine.eval_ast_with_scope::<rhai::Dynamic>(rhai_scope, &combined)
                }
                Err(e) => Err(e.into())
            }
        } else {
            rhai_engine.eval_with_scope::<rhai::Dynamic>(rhai_scope, code)
        };
        match result {
            Ok(valor) => {
                if valor.type_name() != "()" {
                    println!("=> {}", valor);
                }
            }
            Err(e) => println!("Erro Rhai: {}", e),
        }
    }
}

/// Handles the `fg` command.
fn handle_fg(tokens: &[String]) {
    if let Some(pid_str) = tokens.get(1) {
        if let Ok(pid_int) = pid_str.parse::<i32>() {
            let pid = Pid::from_raw(pid_int);

            let _ = signal::kill(pid, Signal::SIGCONT);
            let _ = unistd::tcsetpgrp(std::io::stdin(), pid);
            let _ = wait::waitpid(pid, Some(WaitPidFlag::WUNTRACED));

            let shell_pgid = unistd::getpid();
            let _ = unistd::tcsetpgrp(std::io::stdin(), shell_pgid);
        }
    } else {
        println!("Uso: fg <PID>");
    }
}

/// Handles the `export` command.
fn handle_export(tokens: &[String]) {
    if tokens.len() < 2 {
        println!("Uso: export VAR=VALOR");
    } else {
        let arg = tokens[1..].join("");
        if let Some((key, value)) = arg.split_once('=') {
            unsafe {
                std::env::set_var(key, value);
            }
        } else {
            println!("Erro: Use formato VAR=VALOR");
        }
    }
}

// -----------------------------------------------------------------------------
// RHAI REPL
// -----------------------------------------------------------------------------

/// Executa o modo interativo dedicado ao Rhai (REPL).
fn run_rhai_repl(rhai_engine: &mut Engine, rhai_scope: &mut Scope, plugin_ast: &Option<AST>) {
    println!("Entrando no modo Rhai (Digite 'exit' para sair)");

    let mut rl = rustyline::DefaultEditor::new().unwrap_or_else(|_| panic!("Falha ao iniciar REPL"));

    let mut input_buffer = String::new();
    let mut open_braces = 0;

    loop {
        let prompt = if input_buffer.is_empty() {
            "rhai> "
        } else {
            "... "
        };

        match rl.readline(prompt) {
            Ok(line) => {
                let trimmed = line.trim();

                if trimmed == "exit" && input_buffer.is_empty() {
                    break;
                }

                open_braces += trimmed.matches('{').count();
                let closed = trimmed.matches('}').count();

                if closed > open_braces {
                    open_braces = 0;
                } else {
                    open_braces -= closed;
                }

                input_buffer.push_str(&line);
                input_buffer.push('\n');

                if open_braces == 0 {
                    // Combina com funÃ§Ãµes do plugin se disponÃ­vel
                    let result = if let Some(ast) = plugin_ast {
                        match rhai_engine.compile(&input_buffer) {
                            Ok(user_ast) => {
                                let combined = ast.clone().merge(&user_ast);
                                rhai_engine.eval_ast_with_scope::<rhai::Dynamic>(rhai_scope, &combined)
                            }
                            Err(e) => Err(e.into())
                        }
                    } else {
                        rhai_engine.eval_with_scope::<rhai::Dynamic>(rhai_scope, &input_buffer)
                    };

                    match result {
                        Ok(val) => {
                            if val.type_name() != "()" {
                                println!("=> {}", val);
                            }
                        }
                        Err(e) => println!("Erro: {}", e),
                    }

                    input_buffer.clear();
                }
            }
            Err(_) => break,
        }
    }
}

// -----------------------------------------------------------------------------
// NOVOS BUILTINS
// -----------------------------------------------------------------------------

/// Handles the `unalias` command - remove um alias.
fn handle_unalias(tokens: &[String], aliases: &mut HashMap<String, String>) {
    if tokens.len() < 2 {
        eprintln!("Uso: unalias <nome>");
        return;
    }

    let name = &tokens[1];
    if aliases.remove(name).is_some() {
        println!("Alias '{}' removido.", name);
    } else {
        eprintln!("Alias '{}' nÃ£o encontrado.", name);
    }
}

/// Handles the `unset` command - remove uma variÃ¡vel de ambiente.
fn handle_unset(tokens: &[String]) {
    if tokens.len() < 2 {
        eprintln!("Uso: unset <VARIAVEL>");
        return;
    }

    for var in &tokens[1..] {
        unsafe {
            env::remove_var(var);
        }
    }
}

/// Handles the `type` command - mostra o tipo de um comando.
fn handle_type(tokens: &[String], aliases: &HashMap<String, String>) {
    if tokens.len() < 2 {
        eprintln!("Uso: type <comando>");
        return;
    }

    let cmd = &tokens[1];

    // Verificar se Ã© um alias
    if let Some(val) = aliases.get(cmd) {
        println!("{} is aliased to '{}'", cmd, val);
        return;
    }

    // Verificar se Ã© um builtin
    let builtins = [
        "cd", "pwd", "alias", "unalias", "export", "unset", "history",
        "source", "load", "plugins", "rhai", "fg", "exit", "type", "help", "version"
    ];
    if builtins.contains(&cmd.as_str()) {
        println!("{} is a shell builtin", cmd);
        return;
    }

    // Verificar se Ã© um executÃ¡vel no PATH
    if let Ok(path_var) = env::var("PATH") {
        for path in path_var.split(':') {
            let full_path = std::path::Path::new(path).join(cmd);
            if full_path.exists() && full_path.is_file() {
                println!("{} is {}", cmd, full_path.display());
                return;
            }
        }
    }

    eprintln!("{}: not found", cmd);
}

/// Handles the `help` command - exibe ajuda.
fn handle_help() {
    println!("\x1b[1;36mâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\x1b[0m");
    println!("\x1b[1;36mâ•‘\x1b[0m           \x1b[1;33mClios Shell v1.0.0\x1b[0m - Comandos Internos           \x1b[1;36mâ•‘\x1b[0m");
    println!("\x1b[1;36mâ• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\x1b[0m");
    println!("\x1b[1;36mâ•‘\x1b[0m \x1b[1;32mNavegaÃ§Ã£o:\x1b[0m                                                   \x1b[1;36mâ•‘\x1b[0m");
    println!("\x1b[1;36mâ•‘\x1b[0m   cd [dir]        Mudar diretÃ³rio (cd - para anterior)       \x1b[1;36mâ•‘\x1b[0m");
    println!("\x1b[1;36mâ•‘\x1b[0m   pwd             Exibir diretÃ³rio atual                     \x1b[1;36mâ•‘\x1b[0m");
    println!("\x1b[1;36mâ•‘\x1b[0m                                                              \x1b[1;36mâ•‘\x1b[0m");
    println!("\x1b[1;36mâ•‘\x1b[0m \x1b[1;32mAliases:\x1b[0m                                                     \x1b[1;36mâ•‘\x1b[0m");
    println!("\x1b[1;36mâ•‘\x1b[0m   alias           Listar todos os aliases                    \x1b[1;36mâ•‘\x1b[0m");
    println!("\x1b[1;36mâ•‘\x1b[0m   alias x='cmd'   Criar alias                                \x1b[1;36mâ•‘\x1b[0m");
    println!("\x1b[1;36mâ•‘\x1b[0m   unalias <nome>  Remover alias                              \x1b[1;36mâ•‘\x1b[0m");
    println!("\x1b[1;36mâ•‘\x1b[0m                                                              \x1b[1;36mâ•‘\x1b[0m");
    println!("\x1b[1;36mâ•‘\x1b[0m \x1b[1;32mVariÃ¡veis:\x1b[0m                                                   \x1b[1;36mâ•‘\x1b[0m");
    println!("\x1b[1;36mâ•‘\x1b[0m   export VAR=val  Definir variÃ¡vel de ambiente               \x1b[1;36mâ•‘\x1b[0m");
    println!("\x1b[1;36mâ•‘\x1b[0m   unset VAR       Remover variÃ¡vel de ambiente               \x1b[1;36mâ•‘\x1b[0m");
    println!("\x1b[1;36mâ•‘\x1b[0m                                                              \x1b[1;36mâ•‘\x1b[0m");
    println!("\x1b[1;36mâ•‘\x1b[0m \x1b[1;32mPlugins (Rhai):\x1b[0m                                              \x1b[1;36mâ•‘\x1b[0m");
    println!("\x1b[1;36mâ•‘\x1b[0m   source <file>   Carregar plugin Rhai                       \x1b[1;36mâ•‘\x1b[0m");
    println!("\x1b[1;36mâ•‘\x1b[0m   plugins         Listar plugins carregados                  \x1b[1;36mâ•‘\x1b[0m");
    println!("\x1b[1;36mâ•‘\x1b[0m   rhai <cÃ³digo>   Executar cÃ³digo Rhai inline                \x1b[1;36mâ•‘\x1b[0m");
    println!("\x1b[1;36mâ•‘\x1b[0m   rhai            Entrar no modo REPL Rhai                   \x1b[1;36mâ•‘\x1b[0m");
    println!("\x1b[1;36mâ•‘\x1b[0m                                                              \x1b[1;36mâ•‘\x1b[0m");
    println!("\x1b[1;36mâ•‘\x1b[0m \x1b[1;32mOutros:\x1b[0m                                                      \x1b[1;36mâ•‘\x1b[0m");
    println!("\x1b[1;36mâ•‘\x1b[0m   history         Exibir histÃ³rico de comandos               \x1b[1;36mâ•‘\x1b[0m");
    println!("\x1b[1;36mâ•‘\x1b[0m   type <cmd>      Mostrar tipo do comando                    \x1b[1;36mâ•‘\x1b[0m");
    println!("\x1b[1;36mâ•‘\x1b[0m   fg <PID>        Trazer processo para foreground            \x1b[1;36mâ•‘\x1b[0m");
    println!("\x1b[1;36mâ•‘\x1b[0m   version         Exibir versÃ£o da shell                     \x1b[1;36mâ•‘\x1b[0m");
    println!("\x1b[1;36mâ•‘\x1b[0m   help            Exibir esta ajuda                          \x1b[1;36mâ•‘\x1b[0m");
    println!("\x1b[1;36mâ•‘\x1b[0m   exit            Sair da shell                              \x1b[1;36mâ•‘\x1b[0m");
    println!("\x1b[1;36mâ•‘\x1b[0m                                                              \x1b[1;36mâ•‘\x1b[0m");
    println!("\x1b[1;36mâ•‘\x1b[0m \x1b[1;32mOperadores:\x1b[0m                                                  \x1b[1;36mâ•‘\x1b[0m");
    println!("\x1b[1;36mâ•‘\x1b[0m   cmd1 | cmd2     Pipeline (conectar stdout -> stdin)        \x1b[1;36mâ•‘\x1b[0m");
    println!("\x1b[1;36mâ•‘\x1b[0m   cmd1 && cmd2    Executar cmd2 se cmd1 sucesso              \x1b[1;36mâ•‘\x1b[0m");
    println!("\x1b[1;36mâ•‘\x1b[0m   cmd > file      Redirecionar stdout para arquivo           \x1b[1;36mâ•‘\x1b[0m");
    println!("\x1b[1;36mâ•‘\x1b[0m   cmd >> file     Append stdout ao arquivo                   \x1b[1;36mâ•‘\x1b[0m");
    println!("\x1b[1;36mâ•‘\x1b[0m   cmd 2> file     Redirecionar stderr para arquivo           \x1b[1;36mâ•‘\x1b[0m");
    println!("\x1b[1;36mâ•‘\x1b[0m   cmd &           Executar em background                     \x1b[1;36mâ•‘\x1b[0m");
    println!("\x1b[1;36mâ•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\x1b[0m");
}


// =====================================================================================
// src/expansion.rs
// =====================================================================================

//! # Expansion Module
//!
//! Handles all types of shell expansions:
//! - Variable expansion ($HOME, $USER, ${VAR})
//! - Tilde expansion (~)
//! - Glob expansion (*.rs, src/*)
//! - Subshell expansion ($(command))
//! - Alias expansion

use glob::glob;
use std::collections::HashMap;
use std::env;
use std::process::Command;

// -----------------------------------------------------------------------------
// VARIABLE EXPANSION
// -----------------------------------------------------------------------------

/// ExpansÃ£o Recursiva de VariÃ¡veis de Ambiente (NÃ­vel 10).
///
/// Varre cada token procurando por padrÃµes `$VAR` ou `${VAR}` e substitui
/// pelo valor real do sistema operacional. Funciona inclusive no meio de strings.
///
/// # Exemplo
/// * Entrada: `echo Backup_$USER.tar.gz`
/// * SaÃ­da: `echo Backup_pedro.tar.gz`
pub fn expand_variables(tokens: Vec<String>) -> Vec<String> {
    tokens
        .into_iter()
        .map(|token| {
            // OtimizaÃ§Ã£o: Se nÃ£o tem '$', retorna o token original imediatamente
            if !token.contains('$') {
                return token;
            }

            let mut output = String::new();
            let mut chars = token.chars().peekable();

            while let Some(c) = chars.next() {
                if c == '$' {
                    // InÃ­cio de uma variÃ¡vel.
                    let mut var_name = String::new();
                    let mut is_bracketed = false;

                    if let Some(&'{') = chars.peek() {
                        is_bracketed = true;
                        chars.next(); // Consome '{'
                    }

                    // LÃª o nome da variÃ¡vel (Letras, NÃºmeros ou Underline)
                    while let Some(&next_c) = chars.peek() {
                        if next_c.is_alphanumeric() || next_c == '_' {
                            var_name.push(next_c);
                            chars.next();
                        } else {
                            if is_bracketed && next_c == '}' {
                                chars.next(); // Consome '}' final
                            }
                            break;
                        }
                    }

                    // Se extraiu um nome vÃ¡lido, busca no Sistema Operacional
                    if !var_name.is_empty() {
                        if let Ok(val) = env::var(&var_name) {
                            output.push_str(&val);
                        }
                    } else {
                        output.push('$');
                    }
                } else {
                    output.push(c);
                }
            }
            output
        })
        .collect()
}

// -----------------------------------------------------------------------------
// TILDE EXPANSION
// -----------------------------------------------------------------------------

/// ExpansÃ£o do Til (`~`).
///
/// No Linux, `~` Ã© um atalho para a pasta HOME do usuÃ¡rio.
/// Esta funÃ§Ã£o substitui tokens que comeÃ§am com `~` pelo caminho absoluto.
///
/// # Exemplos
/// * `cd ~` -> `cd /home/pedro`
/// * `ls ~/Downloads` -> `ls /home/pedro/Downloads`
pub fn expand_tilde(tokens: Vec<String>) -> Vec<String> {
    let home = env::var("HOME").unwrap_or_else(|_| "/".to_string());

    tokens
        .into_iter()
        .map(|t| {
            if t == "~" {
                home.clone()
            } else if t.starts_with("~/") {
                format!("{}{}", home, &t[1..])
            } else {
                t
            }
        })
        .collect()
}

// -----------------------------------------------------------------------------
// GLOB EXPANSION
// -----------------------------------------------------------------------------

/// ExpansÃ£o de "Globs" (Curingas de Arquivo).
///
/// Utiliza a crate `glob` para transformar padrÃµes como `*.rs` ou `src/*`
/// em uma lista de arquivos reais do disco.
///
/// # Comportamento
/// * Se encontrar arquivos: Substitui o token pela lista de arquivos.
/// * Se NÃƒO encontrar: MantÃ©m o token original.
pub fn expand_globs(tokens: Vec<String>) -> Vec<String> {
    let mut expanded_tokens = Vec::new();
    for token in tokens {
        if token.contains('*') || token.contains('?') {
            match glob(&token) {
                Ok(paths) => {
                    let mut found = false;
                    for p in paths.flatten() {
                        if let Some(s) = p.to_str() {
                            expanded_tokens.push(s.to_string());
                            found = true;
                        }
                    }
                    if !found {
                        expanded_tokens.push(token);
                    }
                }
                Err(_) => {
                    expanded_tokens.push(token);
                }
            }
        } else {
            expanded_tokens.push(token);
        }
    }
    expanded_tokens
}

// -----------------------------------------------------------------------------
// SUBSHELL EXPANSION
// -----------------------------------------------------------------------------

/// ExpansÃ£o de "Command Substitution" ou Subshell `$()`.
///
/// Detecta padrÃµes `$(comando)` dentro de uma string, executa o comando ocultamente,
/// captura a saÃ­da (STDOUT) e substitui o padrÃ£o pelo resultado.
///
/// # Exemplo
/// * Entrada: `echo Hoje Ã© $(date)`
/// * ExecuÃ§Ã£o: Roda `date`, captura "SÃ¡b Dez 14..."
/// * SaÃ­da: `echo Hoje Ã© SÃ¡b Dez 14...`
pub fn expand_subshells(input: &str) -> String {
    let mut output = String::new();
    let mut chars = input.chars().peekable();

    while let Some(c) = chars.next() {
        if c == '$' && chars.peek() == Some(&'(') {
            chars.next(); // Consome o '(' inicial

            let mut nested = 0;
            let mut inner = String::new();
            let mut closed = false;

            for inner_c in chars.by_ref() {
                if inner_c == '(' {
                    nested += 1;
                    inner.push(inner_c);
                } else if inner_c == ')' {
                    if nested > 0 {
                        nested -= 1;
                        inner.push(inner_c);
                    } else {
                        closed = true;
                        break;
                    }
                } else {
                    inner.push(inner_c);
                }
            }

            if closed {
                if inner.trim().is_empty() {
                    eprintln!("\x1b[1;33m[AVISO]\x1b[0m Subshell vazio: $()");
                } else {
                    let result = execute_and_capture(&inner);
                    output.push_str(&result);
                }
            } else {
                eprintln!("\x1b[1;31m[ERRO SINTAXE]\x1b[0m Subshell nÃ£o fechado: $({}", inner);
                output.push_str("$(");
                output.push_str(&inner);
            }
            continue;
        }
        output.push(c);
    }
    output
}

/// Executa um comando e captura sua saÃ­da (STDOUT) como string.
fn execute_and_capture(cmd_line: &str) -> String {
    let tokens = match shlex::split(cmd_line) {
        Some(t) => t,
        None => {
            eprintln!("\x1b[1;31m[ERRO]\x1b[0m Falha ao processar subshell: '{}'", cmd_line);
            return String::new();
        }
    };
    if tokens.is_empty() {
        return String::new();
    }

    let prog = &tokens[0];
    let args = &tokens[1..];

    // Truque para recursÃ£o Rhai
    if prog == "rhai"
        && let Ok(myself) = env::current_exe() {
            let output = Command::new(myself).arg("-c").arg(cmd_line).output();

            return match output {
                Ok(out) => {
                    if !out.status.success() {
                        eprintln!("\x1b[1;33m[AVISO]\x1b[0m Comando rhai no subshell falhou");
                    }
                    String::from_utf8_lossy(&out.stdout).trim().to_string()
                },
                Err(e) => {
                    eprintln!("\x1b[1;31m[ERRO]\x1b[0m Falha ao executar subshell rhai: {}", e);
                    String::new()
                }
            };
        }

    // ExecuÃ§Ã£o normal
    let output = Command::new(prog).args(args).output();

    match output {
        Ok(out) => {
            if !out.status.success() {
                eprintln!("\x1b[1;33m[AVISO]\x1b[0m Comando '{}' no subshell retornou erro", prog);
            }
            String::from_utf8_lossy(&out.stdout).trim().to_string()
        },
        Err(e) => {
            eprintln!("\x1b[1;31m[ERRO]\x1b[0m Comando '{}' nÃ£o encontrado no subshell: {}", prog, e);
            String::new()
        }
    }
}

// -----------------------------------------------------------------------------
// ALIAS EXPANSION
// -----------------------------------------------------------------------------

/// ExpansÃ£o de Alias em NÃ­vel de String (NÃ­vel 10.1).
///
/// NecessÃ¡ria para aliases complexos que contÃªm `&&` ou `|`.
/// Em vez de expandir token a token (que acontece tarde demais),
/// expandimos a string bruta antes do parser lÃ³gico rodar.
///
/// Inclui proteÃ§Ã£o contra aliases recursivos infinitos.
pub fn expand_alias_string(input: &str, aliases: &HashMap<String, String>) -> String {
    expand_alias_string_with_depth(input, aliases, 0)
}

fn expand_alias_string_with_depth(input: &str, aliases: &HashMap<String, String>, depth: usize) -> String {
    // Prevenir recursÃ£o infinita (mÃ¡ximo 10 nÃ­veis)
    if depth > 10 {
        eprintln!("\x1b[1;33m[AVISO]\x1b[0m Alias recursivo detectado, interrompendo expansÃ£o");
        return input.to_string();
    }

    let trimmed = input.trim_start();

    // Acha onde termina a primeira palavra (o nome do comando)
    let end_idx = trimmed
        .char_indices()
        .find(|(_, c)| c.is_whitespace())
        .map(|(i, _)| i)
        .unwrap_or(trimmed.len());

    let first_word = &trimmed[..end_idx];

    if let Some(val) = aliases.get(first_word) {
        let remainder = &trimmed[end_idx..];
        let expanded = format!("{}{}", val, remainder);
        
        // Verificar se o alias expandido comeÃ§a com o mesmo comando (recursÃ£o direta)
        let expanded_first_word = expanded.split_whitespace()
            .next()
            .unwrap_or("");
        
        if expanded_first_word == first_word {
            eprintln!("\x1b[1;33m[AVISO]\x1b[0m Alias '{}' se refere a si mesmo, usando comando original", first_word);
            return input.to_string();
        }
        
        // Tentar expandir recursivamente
        expand_alias_string_with_depth(&expanded, aliases, depth + 1)
    } else {
        input.to_string()
    }
}

// -----------------------------------------------------------------------------
// LOGICAL AND PARSER
// -----------------------------------------------------------------------------

/// Parser LÃ³gico de `&&` com Contexto (NÃ­vel 10).
///
/// Esta funÃ§Ã£o resolve o bug onde `echo "a && b"` era dividido incorretamente.
/// Ela percorre a string caractere por caractere mantendo um **Estado Interno**
/// para saber se estÃ¡ dentro de aspas ou nÃ£o.
pub fn split_logical_and(input: &str) -> Vec<String> {
    let mut parts = Vec::new();
    let mut current_part = String::new();

    let mut in_single_quote = false;
    let mut in_double_quote = false;

    let mut chars = input.chars().peekable();

    while let Some(c) = chars.next() {
        match c {
            '\'' => {
                if !in_double_quote {
                    in_single_quote = !in_single_quote;
                }
                current_part.push(c);
            }
            '"' => {
                if !in_single_quote {
                    in_double_quote = !in_double_quote;
                }
                current_part.push(c);
            }
            '&' => {
                if !in_single_quote && !in_double_quote
                    && let Some(&'&') = chars.peek() {
                        if !current_part.trim().is_empty() {
                            parts.push(current_part.clone());
                        }
                        current_part.clear();
                        chars.next(); // Consome o segundo '&'
                        continue;
                    }
                current_part.push(c);
            }
            _ => current_part.push(c),
        }
    }

    if !current_part.trim().is_empty() {
        parts.push(current_part);
    }
    parts
}


// =====================================================================================
// src/pipeline.rs
// =====================================================================================

//! # Pipeline Module
//!
//! Handles pipeline execution, I/O redirection, and process management.
//!
//! ## Funcionalidades
//! - ExecuÃ§Ã£o de pipelines de comandos (`cmd1 | cmd2 | cmd3`)
//! - Redirecionamento de I/O (`>`, `>>`, `2>`, `2>>`)
//! - Gerenciamento de processos filhos

use std::fs::{File, OpenOptions};
use std::process::{Child, Command, Stdio};

// -----------------------------------------------------------------------------
// CONSTANTES
// -----------------------------------------------------------------------------

/// CÃ³digo de saÃ­da padrÃ£o POSIX para "comando nÃ£o encontrado"
const EXIT_COMMAND_NOT_FOUND: i32 = 127;

/// CÃ³digo de saÃ­da para erros genÃ©ricos
const EXIT_ERROR: i32 = 1;

// -----------------------------------------------------------------------------
// I/O REDIRECTION PARSING
// -----------------------------------------------------------------------------

/// Analisa e processa operadores de redirecionamento de I/O (NÃ­vel 9).
///
/// Esta funÃ§Ã£o percorre a lista de tokens procurando por operadores especiais
/// de redirecionamento. Quando encontra, ela abre o arquivo correspondente
/// e o remove da lista de argumentos do comando.
///
/// # Operadores Suportados
/// * `>`   : Redireciona **STDOUT** (Sobrescreve o arquivo).
/// * `>>`  : Redireciona **STDOUT** (Adiciona ao final do arquivo - Append).
/// * `2>`  : Redireciona **STDERR** (Sobrescreve o arquivo).
/// * `2>>` : Redireciona **STDERR** (Adiciona ao final do arquivo - Append).
///
/// # Retorno
/// Retorna uma tupla `(Vec<String>, Option<File>, Option<File>)`:
/// 1. **Argumentos Limpos:** O comando sem os sÃ­mbolos de redirecionamento.
/// 2. **Arquivo SaÃ­da:** O arquivo aberto para onde vai o stdout (se houver).
/// 3. **Arquivo Erro:** O arquivo aberto para onde vai o stderr (se houver).
pub fn parse_redirection(tokens: &[String]) -> (Vec<String>, Option<File>, Option<File>) {
    let mut clean = Vec::new();
    let mut stdout_file = None;
    let mut stderr_file = None;

    let mut iter = tokens.iter().peekable();

    while let Some(t) = iter.next() {
        match t.as_str() {
            // SaÃ­da PadrÃ£o (Overwrite)
            ">" => {
                if let Some(f) = iter.next() {
                    match OpenOptions::new()
                        .write(true)
                        .create(true)
                        .truncate(true)
                        .open(f)
                    {
                        Ok(o) => stdout_file = Some(o),
                        Err(e) => {
                            eprintln!("\x1b[1;31m[ERRO REDIRECIONAMENTO]\x1b[0m Falha ao abrir '{}': {}", f, e);
                        }
                    }
                } else {
                    eprintln!("\x1b[1;31m[ERRO SINTAXE]\x1b[0m Operador '>' requer um arquivo");
                }
            }
            // SaÃ­da PadrÃ£o (Append)
            ">>" => {
                if let Some(f) = iter.next() {
                    match OpenOptions::new()
                        
                        .create(true)
                        .append(true)
                        .open(f)
                    {
                        Ok(o) => stdout_file = Some(o),
                        Err(e) => {
                            eprintln!("\x1b[1;31m[ERRO REDIRECIONAMENTO]\x1b[0m Falha ao abrir '{}': {}", f, e);
                        }
                    }
                } else {
                    eprintln!("\x1b[1;31m[ERRO SINTAXE]\x1b[0m Operador '>>' requer um arquivo");
                }
            }
            // SaÃ­da de Erro (Overwrite)
            "2>" => {
                if let Some(f) = iter.next() {
                    match OpenOptions::new()
                        .write(true)
                        .create(true)
                        .truncate(true)
                        .open(f)
                    {
                        Ok(o) => stderr_file = Some(o),
                        Err(e) => {
                            eprintln!("\x1b[1;31m[ERRO REDIRECIONAMENTO]\x1b[0m Falha ao abrir '{}': {}", f, e);
                        }
                    }
                } else {
                    eprintln!("\x1b[1;31m[ERRO SINTAXE]\x1b[0m Operador '2>' requer um arquivo");
                }
            }
            // SaÃ­da de Erro (Append)
            "2>>" => {
                if let Some(f) = iter.next() {
                    match OpenOptions::new()
                        
                        .create(true)
                        .append(true)
                        .open(f)
                    {
                        Ok(o) => stderr_file = Some(o),
                        Err(e) => {
                            eprintln!("\x1b[1;31m[ERRO REDIRECIONAMENTO]\x1b[0m Falha ao abrir '{}': {}", f, e);
                        }
                    }
                } else {
                    eprintln!("\x1b[1;31m[ERRO SINTAXE]\x1b[0m Operador '2>>' requer um arquivo");
                }
            }
            // Token normal
            _ => clean.push(t.clone()),
        }
    }
    (clean, stdout_file, stderr_file)
}

// -----------------------------------------------------------------------------
// PIPELINE EXECUTION
// -----------------------------------------------------------------------------

/// Executa uma "Pipeline" de comandos (ex: `ls | grep txt | wc -l`).
///
/// Esta Ã© a funÃ§Ã£o que realmente faz os programas rodarem. Ela gerencia:
/// 1. **Pipes:** Conecta a saÃ­da de um comando na entrada do prÃ³ximo.
/// 2. **Redirecionamento:** Conecta arquivos (`>`, `2>`) se necessÃ¡rio.
/// 3. **Exit Codes:** Captura se o comando deu certo ou errado.
///
/// # Como funciona (The Daisy Chain)
/// Em um pipe `A | B | C`:
/// * **A**: Stdin = Teclado, Stdout = Pipe(A->B)
/// * **B**: Stdin = Pipe(A->B), Stdout = Pipe(B->C)
/// * **C**: Stdin = Pipe(B->C), Stdout = Tela
pub fn execute_pipeline(commands: Vec<Vec<String>>) -> i32 {
    // ValidaÃ§Ã£o: pipeline vazio
    if commands.is_empty() {
        return 0;
    }

    // ValidaÃ§Ã£o: todos os comandos estÃ£o vazios
    if commands.iter().all(|cmd| cmd.is_empty()) {
        eprintln!("\x1b[1;33m[AVISO]\x1b[0m Pipeline vazio detectado");
        return 0;
    }

    let mut prev_cmd: Option<Child> = None;
    let mut final_exit_code = 0;

    for (i, tokens) in commands.iter().enumerate() {
        if tokens.is_empty() {
            eprintln!("\x1b[1;33m[AVISO]\x1b[0m Comando vazio no pipeline (posiÃ§Ã£o {})", i + 1);
            continue;
        }

        // 1. Separa o comando dos redirecionamentos de arquivo
        let (mut args, outfile, errfile) = parse_redirection(tokens);

        if args.is_empty() {
            continue;
        }

        let cmd = args.remove(0);

        // 2. ConfiguraÃ§Ã£o do STDIN
        let stdin = if let Some(mut child) = prev_cmd {
            Stdio::from(child.stdout.take().unwrap())
        } else {
            Stdio::inherit()
        };

        // 3. ConfiguraÃ§Ã£o do STDOUT
        let stdout = if let Some(f) = outfile {
            Stdio::from(f)
        } else if i < commands.len() - 1 {
            Stdio::piped()
        } else {
            Stdio::inherit()
        };

        // 4. ConfiguraÃ§Ã£o do STDERR
        let stderr = if let Some(f) = errfile {
            Stdio::from(f)
        } else {
            Stdio::inherit()
        };

        // 5. Executa (Spawn)
        match Command::new(&cmd)
            .args(&args)
            .stdin(stdin)
            .stdout(stdout)
            .stderr(stderr)
            .spawn()
        {
            Ok(child) => prev_cmd = Some(child),
            Err(e) => {
                // Mensagem de erro mais descritiva baseada no tipo de erro
                let error_msg = if e.kind() == std::io::ErrorKind::NotFound {
                    format!("comando nÃ£o encontrado: '{}'", cmd)
                } else if e.kind() == std::io::ErrorKind::PermissionDenied {
                    format!("permissÃ£o negada: '{}'", cmd)
                } else {
                    format!("erro ao executar '{}': {}", cmd, e)
                };
                eprintln!("\x1b[1;31m[ERRO]\x1b[0m {}", error_msg);
                return EXIT_COMMAND_NOT_FOUND;
            }
        }
    }

    // 6. Espera Final
    if let Some(mut final_child) = prev_cmd
        && let Ok(status) = final_child.wait() {
            final_exit_code = status.code().unwrap_or(EXIT_ERROR);
        }

    final_exit_code
}


// =====================================================================================
// src/prompt.rs
// =====================================================================================

//! # Prompt Module
//!
//! Handles prompt building, including the Powerline theme and Git branch detection.

use crate::config::{CargoToml, CliosConfig, PackageJson, PyProjectToml};
use chrono::Local;
use std::fs;
use std::process::{Command, Stdio};

// -----------------------------------------------------------------------------
// POWERLINE SEGMENT
// -----------------------------------------------------------------------------

/// Estrutura para representar um "bloco" colorido do prompt
pub struct PowerlineSegment {
    pub text: String,
    pub bg: String, // CÃ³digo de cor ANSI do fundo (ex: "218")
    pub fg: String, // CÃ³digo de cor ANSI do texto (ex: "0" para preto)
}

// -----------------------------------------------------------------------------
// GIT DETECTION
// -----------------------------------------------------------------------------

/// Detecta a Branch do Git para o Prompt (NÃ­vel 7).
///
/// Executa `git branch --show-current` em um processo separado.
/// O `stderr` Ã© descartado para evitar mensagens de erro caso a pasta
/// atual nÃ£o seja um repositÃ³rio git.
pub fn get_git_branch() -> Option<String> {
    let output = Command::new("git")
        .arg("branch")
        .arg("--show-current")
        .stderr(Stdio::null()) // Silencia erros
        .output()
        .ok()?;

    if output.status.success() {
        let branch = String::from_utf8_lossy(&output.stdout).trim().to_string();
        if !branch.is_empty() {
            return Some(branch);
        }
    }
    None
}

// -----------------------------------------------------------------------------
// VERSION READING
// -----------------------------------------------------------------------------

/// Tenta ler a versÃ£o do arquivo Cargo.toml
pub fn get_rust_version() -> Option<String> {
    let content = fs::read_to_string("Cargo.toml").ok()?;
    let cargo: CargoToml = toml::from_str(&content).ok()?;
    Some(format!("v{}", cargo.package.version))
}

/// Tenta ler a versÃ£o do arquivo package.json
pub fn get_node_version() -> Option<String> {
    let content = fs::read_to_string("package.json").ok()?;
    let pkg: PackageJson = serde_json::from_str(&content).ok()?;
    Some(format!("v{}", pkg.version))
}

/// LÃª versÃ£o do Python (pyproject.toml)
pub fn get_python_version() -> Option<String> {
    let content = fs::read_to_string("pyproject.toml").ok()?;
    let py: PyProjectToml = toml::from_str(&content).ok()?;

    // Tenta achar no padrÃ£o oficial [project]
    if let Some(proj) = py.project
        && let Some(v) = proj.version {
            return Some(format!("v{}", v));
        }

    // Se nÃ£o achar, tenta no Poetry [tool.poetry]
    if let Some(tool) = py.tool
        && let Some(poetry) = tool.poetry
            && let Some(v) = poetry.version {
                return Some(format!("v{}", v));
            }

    None
}

// -----------------------------------------------------------------------------
// POWERLINE PROMPT BUILDING
// -----------------------------------------------------------------------------

/// ConstrÃ³i o prompt estilo Powerline "Costurando" os segmentos.
/// Cada segmento Ã© uma struct com texto, cor de fundo e cor de texto.
pub fn build_powerline_prompt(segments: Vec<PowerlineSegment>) -> String {
    let mut prompt = String::new();

    // 1. Borda Redonda Inicial (O Truque)
    if let Some(first) = segments.first() {
        // Define a cor do TEXTO (38) igual ao FUNDO do primeiro bloco (first.bg)
        // \u{e0b6} Ã© o caractere de semicÃ­rculo
        prompt.push_str(&format!("\x1b[38;5;{}m\u{e0b6}", first.bg));
    }

    for (i, segment) in segments.iter().enumerate() {
        // Desenha o bloco
        prompt.push_str(&format!(
            "\x1b[48;5;{}m\x1b[38;5;{}m {} ",
            segment.bg, segment.fg, segment.text
        ));

        // LÃ³gica do TriÃ¢ngulo de conexÃ£o
        let next_bg = if i + 1 < segments.len() {
            format!("\x1b[48;5;{}m", segments[i + 1].bg)
        } else {
            "\x1b[0m".to_string() // Fundo transparente no final
        };

        let current_bg_as_fg = format!("\x1b[38;5;{}m", segment.bg);

        prompt.push_str(&format!("{}{}\u{e0b0}", next_bg, current_bg_as_fg));
    }

    // Adiciona reset de cor e espaÃ§o
    prompt.push_str("\x1b[0m");
    prompt
}

/// Gera os segmentos do Powerline com base no estado atual da Shell.
/// Cada segmento Ã© uma struct com texto, cor de fundo e cor de texto.
/// 1. Ãcone do SO + UsuÃ¡rio
/// 2. DiretÃ³rio Atual
/// 3. Git Branch
/// 4. Contexto de Linguagem
/// 5. RelÃ³gio
pub fn get_powerline_segments(_config: &CliosConfig) -> Vec<PowerlineSegment> {
    let mut segments = Vec::new();

    // 1. Ãcone do SO + UsuÃ¡rio (Rosa - Cor 218)
    let user = std::env::var("USER").unwrap_or("clios".to_string());
    segments.push(PowerlineSegment {
        text: format!("ğŸ§ {}", user),
        bg: "218".to_string(), // Rosa pastel
        fg: "0".to_string(),   // Preto
    });

    // 2. DiretÃ³rio Atual (Laranja - Cor 215)
    if let Ok(path) = std::env::current_dir() {
        let path_str = path.display().to_string();
        // Truque para encurtar o home
        let home = std::env::var("HOME").unwrap_or_default();
        let short_path = path_str.replace(&home, "~");

        segments.push(PowerlineSegment {
            text: short_path,
            bg: "215".to_string(), // Laranja
            fg: "0".to_string(),
        });
    }

    // 3. Git Branch (Amarelo - Cor 229)
    if let Some(branch) = get_git_branch() {
        segments.push(PowerlineSegment {
            text: format!(" {}", branch), // Ãcone de branch
            bg: "229".to_string(),         // Amarelo claro
            fg: "0".to_string(),
        });
    }

    // 4. Contexto de Linguagem (Verde - Cor 150)
    struct LangRule {
        file: &'static str,
        icon: &'static str,
        color: String,
        get_ver: fn() -> Option<String>,
    }

    let languages = [
        LangRule {
            file: "Cargo.toml",
            icon: "",
            color: "150".to_string(),
            get_ver: get_rust_version,
        },
        LangRule {
            file: "package.json",
            icon: "â¬¢",
            color: "150".to_string(),
            get_ver: get_node_version,
        },
        LangRule {
            file: "pyproject.toml",
            icon: "",
            color: "220".to_string(),
            get_ver: get_python_version,
        },
    ];

    let mut found_lang = false;
    for lang in languages.iter() {
        if std::path::Path::new(lang.file).exists() {
            let version = (lang.get_ver)().unwrap_or_else(|| "".to_string());

            segments.push(PowerlineSegment {
                text: format!("{} {}", lang.icon, version).trim().to_string(),
                bg: lang.color.clone(),
                fg: "0".to_string(),
            });
            found_lang = true;
            break;
        }
    }

    // Se nÃ£o achou pyproject.toml mas tem arquivos python soltos
    if !found_lang
        && (std::path::Path::new("requirements.txt").exists()
            || std::path::Path::new("main.py").exists())
    {
        segments.push(PowerlineSegment {
            text: "ğŸ Py".to_string(),
            bg: "220".to_string(),
            fg: "0".to_string(),
        });
    }

    // 5. RelÃ³gio (Azul - Cor 117)
    let time = Local::now().format("%H:%M").to_string();
    segments.push(PowerlineSegment {
        text: format!("ğŸ•‘ {}", time),
        bg: "117".to_string(),
        fg: "0".to_string(),
    });

    segments
}


// =====================================================================================
// src/jobs.rs
// =====================================================================================

//! # Jobs Module
//!
//! Handles job control with low-level Unix process management.
//! Uses `nix` crate for fork/exec and signal handling.

use nix::sys::signal::{self, SigHandler, Signal};
use nix::sys::wait::{self, WaitPidFlag, WaitStatus};
use nix::unistd;
use std::process::Command;

// -----------------------------------------------------------------------------
// JOB CONTROL EXECUTION
// -----------------------------------------------------------------------------

/// ExecuÃ§Ã£o de baixo nÃ­vel com controle total de Processos (Job Control - NÃ­vel 5).
///
/// Diferente do `execute_pipeline` (que usa a std lib), esta funÃ§Ã£o usa `nix` para
/// chamar `fork` e `exec` manualmente. Isso Ã© necessÃ¡rio para manipular
/// **Process Groups** e definir quem Ã© o "dono" do terminal.
///
/// # A DanÃ§a do Terminal (Terminal Handoff)
/// Para que o `Ctrl+C` vÃ¡ para o processo certo, precisamos transferir a posse
/// do terminal (STDIN) da Shell para o Processo Filho.
///
/// 1. **Shell:** Ignora `SIGTTOU` (para nÃ£o ser suspensa ao mexer no terminal).
/// 2. **Fork:** Cria uma cÃ³pia do processo.
/// 3. **Pai & Filho:** Ambos tentam setar o `setpgid` (para evitar race conditions).
/// 4. **Pai:** DÃ¡ o terminal pro filho (`tcsetpgrp`) e espera (`waitpid`).
/// 5. **Pai:** Quando o filho morre/para, pega o terminal de volta.
pub fn execute_job_control(tokens: Vec<String>, background: bool) {
    // SeguranÃ§a: Ignorar SIGTTOU na shell
    unsafe { signal::signal(Signal::SIGTTOU, SigHandler::SigIgn) }.unwrap();

    match unsafe { unistd::fork() } {
        Ok(unistd::ForkResult::Parent { child, .. }) => {
            // --- CÃ“DIGO DO PAI (SHELL) ---
            let pgid = child;

            let _ = unistd::setpgid(child, pgid);

            if !background {
                let _ = unistd::tcsetpgrp(std::io::stdin(), pgid);

                match wait::waitpid(child, Some(WaitPidFlag::WUNTRACED)) {
                    Ok(WaitStatus::Stopped(_, _sig)) => {
                        println!("\n[Job {}] Pausado (Ctrl+Z)", child);
                    }
                    Ok(WaitStatus::Signaled(_, sig, _)) => {
                        println!("\n[Job {}] Morto pelo sinal: {:?}", child, sig);
                    }
                    _ => {}
                }

                let shell_pgid = unistd::getpid();
                let _ = unistd::tcsetpgrp(std::io::stdin(), shell_pgid);
            } else {
                println!("[Background Job {}]", child);
            }
        }
        Ok(unistd::ForkResult::Child) => {
            // --- CÃ“DIGO DO FILHO (COMANDO) ---
            let pid = unistd::getpid();
            let _ = unistd::setpgid(pid, pid);

            if !background {
                let _ = unistd::tcsetpgrp(std::io::stdin(), pid);
            }

            unsafe { signal::signal(Signal::SIGTTOU, SigHandler::SigDfl) }.unwrap();
            unsafe { signal::signal(Signal::SIGINT, SigHandler::SigDfl) }.unwrap();

            use std::os::unix::process::CommandExt;

            let err = Command::new(&tokens[0]).args(&tokens[1..]).exec();

            eprintln!("Erro ao executar '{}': {}", tokens[0], err);
            std::process::exit(1);
        }
        Err(_) => println!("Fork falhou - Sistema sem recursos"),
    }
}


// =====================================================================================
// src/rhai_integration.rs
// =====================================================================================

//! # Rhai Integration Module
//!
//! Handles the Rhai scripting engine setup, including all registered functions
//! and script execution.

use rhai::{Engine, EvalAltResult, Scope, AST};

// -----------------------------------------------------------------------------
// ENGINE CREATION
// -----------------------------------------------------------------------------

/// Creates and configures a new Rhai engine with all shell functions registered.
pub fn create_rhai_engine() -> Engine {
    let mut engine = Engine::new();

    // --- shell_exec function ---
    engine.register_fn("shell_exec", |cmd_str: &str| -> rhai::Map {
        let parts: Vec<&str> = cmd_str.split_whitespace().collect();
        let mut map = rhai::Map::new();

        if parts.is_empty() {
            map.insert("success".into(), false.into());
            return map;
        }

        match std::process::Command::new(parts[0])
            .args(&parts[1..])
            .output()
        {
            Ok(output) => {
                let stdout = String::from_utf8_lossy(&output.stdout).trim().to_string();
                let stderr = String::from_utf8_lossy(&output.stderr).trim().to_string();
                let combined = format!("{}{}", stdout, stderr).trim().to_string();

                map.insert("success".into(), output.status.success().into());
                map.insert("output".into(), combined.into());
                map
            }
            Err(e) => {
                map.insert("success".into(), false.into());
                map.insert("output".into(), e.to_string().into());
                map
            }
        }
    });

    // --- confirm function (UI Widget) ---
    engine.register_fn("confirm", |prompt: &str| -> bool {
        match inquire::Confirm::new(prompt).with_default(false).prompt() {
            Ok(true) => true,
            Ok(false) => false,
            Err(_) => false,
        }
    });

    // --- select function (UI Widget) ---
    engine.register_fn(
        "select",
        |prompt: &str, options: Vec<rhai::Dynamic>| -> String {
            let items: Vec<String> = options.iter().map(|item| item.to_string()).collect();

            inquire::Select::new(prompt, items).prompt().unwrap_or_default()
        },
    );

    // --- input function ---
    engine.register_fn("input", |prompt: &str| -> String {
        use std::io::{self, Write};
        print!("{}", prompt);
        let _ = io::stdout().flush();

        let mut buffer = String::new();
        let _ = io::stdin().read_line(&mut buffer);
        buffer.trim().to_string()
    });

    // --- http_get function ---
    engine.register_fn("http_get", |url: &str| -> String {
        match reqwest::blocking::get(url) {
            Ok(resp) => {
                if resp.status().is_success() {
                    resp.text()
                        .unwrap_or_else(|_| "Erro: Corpo vazio".to_string())
                } else {
                    format!("Erro HTTP: {}", resp.status())
                }
            }
            Err(e) => format!("Erro de ConexÃ£o: {}", e),
        }
    });

    // --- save_file function ---
    engine.register_fn("save_file", |path: &str, content: &str| -> bool {
        if let Some(parent) = std::path::Path::new(path).parent() {
            let _ = std::fs::create_dir_all(parent);
        }
        std::fs::write(path, content).is_ok()
    });

    engine
}

// -----------------------------------------------------------------------------
// SCRIPT EXECUTION
// -----------------------------------------------------------------------------

/// Inicializa e executa um script Rhai externo (.rhai).
///
/// Diferente do modo interativo, esta funÃ§Ã£o cria um motor "limpo" e novo.
/// Isso garante que scripts rodem em um ambiente isolado.
pub fn run_rhai_script(path: &str) -> Result<(), Box<EvalAltResult>> {
    let mut engine = Engine::new();

    engine.register_fn("shell_exec", |cmd_str: &str| -> rhai::Map {
        let parts: Vec<&str> = cmd_str.split_whitespace().collect();
        let mut map = rhai::Map::new();

        if parts.is_empty() {
            map.insert("success".into(), false.into());
            return map;
        }

        match std::process::Command::new(parts[0])
            .args(&parts[1..])
            .output()
        {
            Ok(output) => {
                let stdout = String::from_utf8_lossy(&output.stdout).trim().to_string();
                let stderr = String::from_utf8_lossy(&output.stderr).trim().to_string();
                let combined = format!("{}{}", stdout, stderr).trim().to_string();

                map.insert("success".into(), output.status.success().into());
                map.insert("output".into(), combined.into());
                map
            }
            Err(e) => {
                map.insert("success".into(), false.into());
                map.insert("output".into(), e.to_string().into());
                map
            }
        }
    });

    engine.register_fn("input", |prompt: &str| -> String {
        use std::io::{self, Write};
        print!("{}", prompt);
        let _ = io::stdout().flush();

        let mut buffer = String::new();
        let _ = io::stdin().read_line(&mut buffer);
        buffer.trim().to_string()
    });

    engine.run_file(path.into())?;

    Ok(())
}

// -----------------------------------------------------------------------------
// PLUGIN MANAGEMENT
// -----------------------------------------------------------------------------

/// Tenta executar uma funÃ§Ã£o do Plugin carregado.
/// Retorna `true` se a funÃ§Ã£o existia e foi executada.
pub fn try_execute_plugin_function(
    engine: &Engine,
    scope: &mut Scope,
    ast: &AST,
    cmd: &str,
    args: Vec<String>,
) -> bool {
    let function_exists = ast.iter_functions().any(|f| f.name == cmd);

    if function_exists {
        let rhai_args: Vec<rhai::Dynamic> =
            args.into_iter().map(rhai::Dynamic::from).collect();

        let result = engine.call_fn::<rhai::Dynamic>(scope, ast, cmd, (rhai_args,));

        match result {
            Ok(_) => return true,
            Err(e) => println!("Erro no Plugin (FunÃ§Ã£o {}): {}", cmd, e),
        }
        return true;
    }
    false
}


// =====================================================================================
// src/completion.rs
// =====================================================================================

//! # Completion Module
//!
//! Provides autocomplete and syntax highlighting for the shell using rustyline.

use rustyline::completion::{Completer, Pair};
use rustyline::highlight::{CmdKind, Highlighter};
use rustyline::hint::HistoryHinter;
use rustyline::Context;
use rustyline::{Helper, Hinter, Validator};
use std::borrow::Cow;
use std::fs;
use which::which;

// -----------------------------------------------------------------------------
// CLIOS HELPER
// -----------------------------------------------------------------------------

/// # CliosHelper (O CÃ©rebro Visual)
///
/// Esta estrutura Ã© exigida pelo `rustyline` para gerenciar a interaÃ§Ã£o com o usuÃ¡rio.
/// Ela agrupa todas as funcionalidades de "UX" (User Experience) do terminal.
///
/// ## Funcionalidades:
/// * **Completer:** Autocomplete de arquivos quando aperta TAB.
/// * **Hinter:** SugestÃ£o cinza baseada no histÃ³rico.
/// * **Highlighter:** Colore o comando enquanto vocÃª digita (Verde/Vermelho).
#[derive(Helper, Hinter, Validator)]
pub struct CliosHelper {
    /// O sugestor baseado no histÃ³rico (HistoryHinter).
    #[rustyline(Hinter)]
    pub hinter: HistoryHinter,

    /// Armazena a versÃ£o colorida do prompt (com cÃ³digos ANSI).
    #[rustyline(Ignore)]
    pub colored_prompt: String,

    /// Cor para comandos vÃ¡lidos.
    #[rustyline(Ignore)]
    pub color_valid: String,

    /// Cor para comandos invÃ¡lidos.
    #[rustyline(Ignore)]
    pub color_invalid: String,
}

impl CliosHelper {
    /// Creates a new CliosHelper with the given colors.
    pub fn new(color_valid: String, color_invalid: String) -> Self {
        Self {
            hinter: HistoryHinter {},
            colored_prompt: String::new(),
            color_valid,
            color_invalid,
        }
    }
}

// -----------------------------------------------------------------------------
// HIGHLIGHTER IMPLEMENTATION
// -----------------------------------------------------------------------------

impl Highlighter for CliosHelper {
    fn highlight_prompt<'b, 's: 'b, 'p: 'b>(
        &'s self,
        prompt: &'p str,
        default: bool,
    ) -> Cow<'b, str> {
        if default {
            Cow::Borrowed(&self.colored_prompt)
        } else {
            Cow::Borrowed(prompt)
        }
    }

    fn highlight<'l>(&self, line: &'l str, _pos: usize) -> Cow<'l, str> {
        let input = line.trim();
        if input.is_empty() {
            return Cow::Borrowed(line);
        }
        let first_word = input.split_whitespace().next().unwrap_or("");

        let is_valid = matches!(
            first_word,
            "cd" | "exit" | "pwd" | "alias" | "rhai" | "fg" | "export" | "history" | "source" | "load" | "plugins"
        ) || which(first_word).is_ok();

        if is_valid {
            Cow::Owned(format!("{}{}\x1b[0m", self.color_valid, line))
        } else {
            Cow::Owned(format!("{}{}\x1b[0m", self.color_invalid, line))
        }
    }

    fn highlight_char(&self, _line: &str, _pos: usize, _forced: CmdKind) -> bool {
        true
    }
}

// -----------------------------------------------------------------------------
// COMPLETER IMPLEMENTATION
// -----------------------------------------------------------------------------

impl Completer for CliosHelper {
    type Candidate = Pair;

    fn complete(
        &self,
        line: &str,
        pos: usize,
        _ctx: &Context,
    ) -> rustyline::Result<(usize, Vec<Pair>)> {
        let (start, path_to_complete) = extract_word(line, pos);
        let mut matches = Vec::new();

        // 1. Identifica diretÃ³rio base e o que estamos digitando
        let (dir, file_prefix) = if let Some(idx) = path_to_complete.rfind('/') {
            (&path_to_complete[..idx + 1], &path_to_complete[idx + 1..])
        } else {
            ("", path_to_complete)
        };

        // Resolve o caminho real para ler o disco
        let dir_path = if dir.is_empty() {
            ".".to_string()
        } else {
            dir.to_string()
        };

        // Tenta ler o diretÃ³rio
        if let Ok(entries) = fs::read_dir(&dir_path) {
            for entry in entries.flatten() {
                if let Ok(name) = entry.file_name().into_string() {
                    // Smart Case: Comparamos tudo em minÃºsculo
                    if name
                        .to_lowercase()
                        .starts_with(&file_prefix.to_lowercase())
                    {
                        let replacement = format!("{}{}", dir, name);

                        matches.push(Pair {
                            display: name,
                            replacement,
                        });
                    }
                }
            }
        }

        Ok((start, matches))
    }
}

// -----------------------------------------------------------------------------
// HELPER FUNCTIONS
// -----------------------------------------------------------------------------

/// FunÃ§Ã£o auxiliar para pegar a palavra que estÃ¡ sendo digitada (separa por espaÃ§os)
fn extract_word(line: &str, pos: usize) -> (usize, &str) {
    let line_before_cursor = &line[..pos];
    if let Some(last_space) = line_before_cursor.rfind(char::is_whitespace) {
        (last_space + 1, &line_before_cursor[last_space + 1..])
    } else {
        (0, line_before_cursor)
    }
}


// =====================================================================================
// src/tests.rs
// =====================================================================================

//! Testes UnitÃ¡rios para Clios Shell
//! 
//! Execute com: cargo test

#[cfg(test)]
mod tests {
    // =========================================================================
    // TESTES DE EXPANSÃƒO
    // =========================================================================

    #[test]
    fn test_expand_variables_simple() {
        use std::env;
        unsafe {
            env::set_var("TEST_VAR", "hello");
        }
        
        let tokens = vec!["$TEST_VAR".to_string()];
        let result = crate::expansion::expand_variables(tokens);
        
        assert_eq!(result, vec!["hello"]);
    }

    #[test]
    fn test_expand_variables_with_braces() {
        use std::env;
        unsafe {
            env::set_var("TEST_VAR", "hello");
        }
        
        let tokens = vec!["${TEST_VAR}".to_string()];
        let result = crate::expansion::expand_variables(tokens);
        
        assert_eq!(result, vec!["hello"]);
    }

    #[test]
    fn test_expand_variables_in_string() {
        use std::env;
        unsafe {
            env::set_var("TESTUSER", "myname");
        }
        
        let tokens = vec!["prefix-$TESTUSER-suffix".to_string()];
        let result = crate::expansion::expand_variables(tokens);
        
        assert!(result[0].contains("myname"), "Expected result to contain 'myname', got: {}", result[0]);
    }

    #[test]
    fn test_expand_tilde() {
        use std::env;
        let home = env::var("HOME").unwrap_or_else(|_| "/home/user".to_string());
        
        let tokens = vec!["~".to_string()];
        let result = crate::expansion::expand_tilde(tokens);
        
        assert_eq!(result[0], home);
    }

    #[test]
    fn test_expand_tilde_with_path() {
        use std::env;
        let home = env::var("HOME").unwrap_or_else(|_| "/home/user".to_string());
        
        let tokens = vec!["~/Documents".to_string()];
        let result = crate::expansion::expand_tilde(tokens);
        
        assert_eq!(result[0], format!("{}/Documents", home));
    }

    #[test]
    fn test_split_logical_and_simple() {
        let input = "echo hello && echo world";
        let result = crate::expansion::split_logical_and(input);
        
        assert_eq!(result.len(), 2);
        assert_eq!(result[0].trim(), "echo hello");
        assert_eq!(result[1].trim(), "echo world");
    }

    #[test]
    fn test_split_logical_and_with_quotes() {
        let input = r#"echo "a && b" && echo test"#;
        let result = crate::expansion::split_logical_and(input);
        
        assert_eq!(result.len(), 2);
        assert!(result[0].contains("a && b"));
    }

    #[test]
    fn test_split_logical_and_no_split() {
        let input = r#"echo "test && test2""#;
        let result = crate::expansion::split_logical_and(input);
        
        assert_eq!(result.len(), 1);
    }

    #[test]
    fn test_expand_alias_simple() {
        use std::collections::HashMap;
        let mut aliases = HashMap::new();
        aliases.insert("ll".to_string(), "ls -la".to_string());
        
        let input = "ll /tmp";
        let result = crate::expansion::expand_alias_string(input, &aliases);
        
        assert_eq!(result, "ls -la /tmp");
    }

    #[test]
    fn test_expand_alias_no_match() {
        use std::collections::HashMap;
        let aliases = HashMap::new();
        
        let input = "ls -la";
        let result = crate::expansion::expand_alias_string(input, &aliases);
        
        assert_eq!(result, "ls -la");
    }

    // =========================================================================
    // TESTES DE PIPELINE
    // =========================================================================

    #[test]
    fn test_parse_redirection_stdout() {
        let tokens = vec![
            "echo".to_string(),
            "test".to_string(),
            ">".to_string(),
            "/tmp/test_output.txt".to_string()
        ];
        
        let (clean, stdout_file, stderr_file) = crate::pipeline::parse_redirection(&tokens);
        
        assert_eq!(clean, vec!["echo", "test"]);
        assert!(stdout_file.is_some());
        assert!(stderr_file.is_none());
    }

    #[test]
    fn test_parse_redirection_stderr() {
        let tokens = vec![
            "ls".to_string(),
            "/nonexistent".to_string(),
            "2>".to_string(),
            "/tmp/test_error.txt".to_string()
        ];
        
        let (clean, stdout_file, stderr_file) = crate::pipeline::parse_redirection(&tokens);
        
        assert_eq!(clean, vec!["ls", "/nonexistent"]);
        assert!(stdout_file.is_none());
        assert!(stderr_file.is_some());
    }

    #[test]
    fn test_parse_redirection_both() {
        let tokens = vec![
            "ls".to_string(),
            "/tmp".to_string(),
            ">".to_string(),
            "/tmp/out.txt".to_string(),
            "2>".to_string(),
            "/tmp/err.txt".to_string()
        ];
        
        let (clean, stdout_file, stderr_file) = crate::pipeline::parse_redirection(&tokens);
        
        assert_eq!(clean, vec!["ls", "/tmp"]);
        assert!(stdout_file.is_some());
        assert!(stderr_file.is_some());
    }

    // =========================================================================
    // TESTES DE SHELL
    // =========================================================================

    #[test]
    fn test_shell_creation() {
        use crate::config::CliosConfig;
        let config = CliosConfig::default();
        let shell = crate::shell::CliosShell::new(config);
        
        assert_eq!(shell.last_exit_code, 0);
        assert!(shell.aliases.is_empty());
        assert!(shell.previous_dir.is_none());
    }

    // =========================================================================
    // TESTES DE SUBSHELLS
    // =========================================================================

    #[test]
    fn test_expand_subshells_simple() {
        let input = "echo $(echo test)";
        let result = crate::expansion::expand_subshells(input);
        
        // O resultado deve conter "test" expandido
        assert!(result.contains("test"));
    }

    #[test]
    fn test_expand_subshells_empty() {
        let input = "echo $()";
        let result = crate::expansion::expand_subshells(input);
        
        // Deve processar sem travar
        assert!(result.contains("echo"));
    }

    #[test]
    fn test_expand_subshells_unclosed() {
        let input = "echo $(echo test";
        let result = crate::expansion::expand_subshells(input);
        
        // Deve retornar algo sem travar
        assert!(result.contains("echo"));
    }

    // =========================================================================
    // TESTES DE PROTEÃ‡ÃƒO CONTRA RECURSÃƒO
    // =========================================================================

    #[test]
    fn test_alias_recursive_protection() {
        use std::collections::HashMap;
        let mut aliases = HashMap::new();
        // Alias que se refere a si mesmo
        aliases.insert("ls".to_string(), "ls -la".to_string());
        
        let input = "ls";
        let result = crate::expansion::expand_alias_string(input, &aliases);
        
        // Deve detectar recursÃ£o e retornar original
        assert_eq!(result, "ls");
    }

    #[test]
    fn test_alias_deep_recursion() {
        use std::collections::HashMap;
        let mut aliases = HashMap::new();
        aliases.insert("a".to_string(), "b".to_string());
        aliases.insert("b".to_string(), "c".to_string());
        aliases.insert("c".to_string(), "d".to_string());
        // ... muitos nÃ­veis
        
        let input = "a";
        let result = crate::expansion::expand_alias_string(input, &aliases);
        
        // Deve parar antes de overflow
        assert!(!result.is_empty());
    }
}
