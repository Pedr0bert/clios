//! # Clios Shell (Command Line Interface & Operating System Shell)
//! # Clios Shell - Arquivo Principal
//!
//! Bem-vindo √† documenta√ß√£o oficial da **Clios**, uma shell h√≠brida desenvolvida em Rust.
//!
//! ## Funcionalidades Principais:
//! * **Interatividade:** Prompt rico com hist√≥rico e autocomplete (via `rustyline`).
//! * **Scripting:** Suporte nativo √† linguagem Rhai para scripts complexos.
//! * **Job Control:** Gerenciamento de processos Unix (bg, fg, signals) via `nix`.
//! * **Parsing:** Suporte a pipes `|`, redirecionamento `>` e l√≥gica `&&`.

//!
//! Este projeto foi constru√≠do seguindo uma jornada de 11 N√≠veis de complexidade de Sistemas Operacionais.
//!
//! ---
//!
//! ## üó∫Ô∏è O Roadmap de Evolu√ß√£o (N√≠veis 1 a 11)
//!
//! A constru√ß√£o da Clios seguiu uma progress√£o l√≥gica, partindo de um simples executor de comandos
//! para uma Shell de sistema completa.
//!
//! ### Fase 1: A Funda√ß√£o (O B√°sico)
//! * **N√≠vel 1 (Hello World):** Cria√ß√£o do loop REPL (Read-Eval-Print Loop) b√°sico.
//! * **N√≠vel 2 (Input):** Integra√ß√£o com `rustyline` para setinhas, hist√≥rico e edi√ß√£o de linha.
//! * **N√≠vel 3 (Persist√™ncia):** Salvamento autom√°tico do hist√≥rico em `~/.clios_history`.
//!
//! ### Fase 2: O Sistema Operacional (Gerenciamento de Estado)
//! * **N√≠vel 4 (Builtins):** Implementa√ß√£o de comandos internos que alteram o estado da shell:
//!     * `cd`: Altera o diret√≥rio atual do processo pai.
//!     * `exit`: Encerra a shell graciosamente.
//! * **N√≠vel 5 (Job Control - O Grande Desafio):**
//!     * Uso da crate `nix` para chamadas de sistema POSIX (`fork`, `exec`, `signals`).
//!     * Implementa√ß√£o de processos em Background (`command &`).
//!     * Controle de terminal (`tcsetpgrp`) para gerenciar quem recebe o `Ctrl+C`.
//!     * Comandos `fg` (Foreground) e suporte a suspens√£o (`Ctrl+Z`).
//!
//! ### Fase 3: A Intelig√™ncia (Scripting & L√≥gica)
//! * **N√≠vel 6 (Scripting H√≠brido):**
//!     * Integra√ß√£o do motor **Rhai** (Embedded Scripting Language).
//!     * Cria√ß√£o de fun√ß√µes ponte (`shell_exec`, `input`) permitindo scripts `.rhai` que controlam o Linux.
//!     * Prote√ß√£o contra falhas cr√≠ticas (`Panic Catching`).
//! * **N√≠vel 6.5 (Modo Interativo):** Cria√ß√£o de um REPL dedicado para Rhai (`rhai>`).
//! * **N√≠vel 10 (Smart Parsing):**
//!     * Implementa√ß√£o de l√≥gica condicional `&&`.
//!     * Parser contextual que respeita aspas (n√£o quebra strings que cont√™m `&&`).
//!
//! ### Fase 4: UX & Encanamento (Polimento Profissional)
//! * **N√≠vel 7 (Git Aware):** O prompt detecta reposit√≥rios Git e mostra a branch atual.
//! * **N√≠vel 8 (Status Codes):** Feedback visual de erro (seta vermelha) baseado no Exit Code.
//! * **N√≠vel 9 (I/O Plumbing):**
//!     * Redirecionamento de arquivos: `>` (Create), `>>` (Append).
//!     * Redirecionamento de erros: `2>`, `2>>`.
//!     * **Pipes:** Encanamento de processos via mem√≥ria (`|`).
//! * **N√≠vel 10 (Expans√£o de Ambiente):**
//!     * Vari√°veis: `$HOME`, `$USER`, `${VAR}`.
//!     * Tilde: `~` expande para `/home/user`.
//!     * Globs: `*.rs` expande para lista de arquivos.
//!
//! ### Fase 5: Identidade (Customiza√ß√£o)
//! * **N√≠vel 11 (Configura√ß√£o TOML):**
//!     * Uso de `serde` e `toml` para ler configura√ß√µes de `~/.clios.toml`.
//!     * Permite customizar cores, s√≠mbolos do prompt e comportamento do hist√≥rico.
//!
//! ---
//!
//! ## üèóÔ∏è Arquitetura do Sistema
//!
//! O fluxo de execu√ß√£o de um comando na Clios segue estas etapas:
//!
//! 1. **Input:** O `rustyline` captura a linha digitada.
//! 2. **Config:** A shell consulta a `CliosConfig` para desenhar o prompt.
//! 3. **Parser L√≥gico:** A linha √© dividida por operadores `&&` (respeitando aspas).
//! 4. **Expans√£o:**
//!    - Aliases s√£o resolvidos.
//!    - Subshells `$()` s√£o executadas e capturadas.
//!    - Vari√°veis de ambiente e Globs s√£o expandidos.
//! 5. **Decis√£o de Execu√ß√£o:**
//!    - √â Script Rhai? -> Envia para `rhai_engine`.
//!    - √â Builtin (`cd`)? -> Executa internamente.
//!    - √â Bin√°rio (`ls`)? -> Cria processo filho (`Command::spawn` ou `fork`).
//!
//! ---
//!
//! ##  Como Usar
//!
//! ```bash
//! # Modo Interativo
//! clios
//!
//! # Executar Script
//! clios script.rhai
//!
//! # Comando √önico
//! clios -c "echo Hello World"
//! ```

// ... AQUI COME√áAM OS SEUS IMPORTS (use std::env; etc) ...
// --- STANDARD LIBRARY (STD) ---
// Ferramentas b√°sicas do Rust para interagir com o sistema operacional.
use std::env;                             // Vari√°veis de ambiente ($HOME, $PATH)
use std::fs::{File, OpenOptions};         // Manipula√ß√£o de arquivos (para redirecionamento >)
use std::io::{BufRead, BufReader};        // Leitura eficiente de arquivos (scripts e configs)
use std::path::Path;                      // Manipula√ß√£o de caminhos de diret√≥rio
use std::process::{Command, Stdio, Child}; // Cria√ß√£o e controle de processos filhos
use std::borrow::Cow;                     // "Clone on Write" (otimiza√ß√£o de strings para o prompt)
use std::collections::HashMap;            // Estrutura chave-valor para guardar os Aliases
use std::fs;                          // Opera√ß√µes de sistema de arquivos (verificar exist√™ncia)    
// --- EXTERNAL CRATES ---

// Biblioteca para encontrar execut√°veis no PATH do sistema (como o comando 'which' do Linux)
use which::which;

// Biblioteca para expans√£o de padr√µes de arquivo (ex: *.rs, src/*)
use glob::glob;

// --- SCRIPTING ENGINE (RHAI) ---
// O c√©rebro l√≥gico da shell. Permite criar scripts, fun√ß√µes e automa√ß√£o.
use rhai::{Engine, Scope, EvalAltResult, AST}; 

// --- SYSTEM CALLS & JOB CONTROL (NIX) ---
// Acesso de baixo n√≠vel a APIs Unix/Linux. Essencial para o N√≠vel 5 (Job Control).
use nix::sys::signal::{self, Signal, SigHandler}; // Manipula√ß√£o de sinais (Ctrl+C, Ctrl+Z)
use nix::unistd::{self, Pid};                     // Identifica√ß√£o de processos e Fork
use nix::sys::wait::{self, WaitStatus, WaitPidFlag}; // Espera de processos filhos

// --- USER INTERFACE (RUSTYLINE) ---
// Fornece a experi√™ncia de linha de comando "moderna" (setinhas, home, end, hist√≥rico).
use rustyline::error::ReadlineError;
use rustyline::{Helper, Hinter, Validator, Editor};
use rustyline::completion::{Completer, Pair}; // Autocomplete de arquivos (Tab)
use rustyline::history::DefaultHistory;       // Gerenciamento do arquivo history.txt
use rustyline::hint::HistoryHinter;           // Sugest√£o cinza baseada no hist√≥rico
use rustyline::highlight::{Highlighter, CmdKind}; // Cores no terminal
use rustyline::Context;                  // Contexto da linha atual

// --- IMPORTS NIVEL 11 ---
use serde::Deserialize;
use std::io::Read; // Para ler o arquivo todo numa string  
use chrono::Local; // Para timestamps no hist√≥rico
// --- ESTRUTURAS DE DADOS ---

// -----------------------------------------------------------------------------
// M√ìDULO DE CONFIGURA√á√ÉO (TOML)
// -----------------------------------------------------------------------------

/// Configura√ß√µes visuais do Prompt de comando.
///
/// Esta estrutura mapeia a se√ß√£o `[prompt]` do arquivo de configura√ß√£o `.clios.toml`.
/// Permite que o usu√°rio personalize cores, s√≠mbolos e informa√ß√µes exibidas.
#[derive(Debug, Deserialize, Clone)]
struct ConfigPrompt {
    /// O s√≠mbolo exibido no final do prompt (ex: `>`, `$`, `‚ûú`, ``).
    /// * Padr√£o: `>`
    symbol: Option<String>,

    /// A cor do s√≠mbolo e do separador.
    /// * Valores aceitos: "red", "green", "blue", "purple", "cyan", "yellow".
    /// * Padr√£o: "blue"
    color: Option<String>,

    /// Cores espec√≠ficas para diferentes partes do prompt.
    /// * Padr√£o: None (usa a cor geral definida em `color`)
    /// Cor do usu√°rio (user@host) 
    path_color: Option<String>,   // Cor do caminho (/mnt/c/...)
    /// Cor do s√≠mbolo (setinha >)
    symbol_color: Option<String>, // Cor da setinha (>)

    /// Define se deve mostrar a branch atual do Git.
    /// * Padr√£o: `true`
    show_git: Option<bool>,
}

// --- N√çVEL 15.5: Leitor de Vers√µes ---

// Struct para ler Cargo.toml
#[derive(serde::Deserialize)]
struct CargoToml {
    package: CargoPackage,
}
#[derive(serde::Deserialize)]
struct CargoPackage {
    version: String,
}

// Struct para ler package.json
#[derive(serde::Deserialize)]
struct PackageJson {
    version: String,
}

// --- Suporte a Python ---

#[derive(serde::Deserialize)]
struct PyProjectToml {
    project: Option<PyProjectSection>,
    tool: Option<PyToolSection>,
}

#[derive(serde::Deserialize)]
struct PyProjectSection {
    version: Option<String>,
}

#[derive(serde::Deserialize)]
struct PyToolSection {
    poetry: Option<PyPoetrySection>,
}

#[derive(serde::Deserialize)]
struct PyPoetrySection {
    version: Option<String>,
}

// Estrutura para representar um "bloco" colorido do prompt
struct PowerlineSegment {
    text: String,
    bg: String, // C√≥digo de cor ANSI do fundo (ex: "218")
    fg: String, // C√≥digo de cor ANSI do texto (ex: "0" para preto)
}
/// Configura√ß√µes do hist√≥rico de comandos.
///
/// Esta estrutura mapeia a se√ß√£o `[history]` do arquivo `.clios.toml`.
#[derive(Debug, Deserialize, Clone)]
struct ConfigHistory {
    /// Nome do arquivo onde o hist√≥rico ser√° salvo na pasta HOME.
    /// * Padr√£o: `.clios_history`
    file: Option<String>,

    /// N√∫mero m√°ximo de comandos a serem lembrados.
    /// * Padr√£o: `1000`
    max_entries: Option<usize>,
}

/// Configura√ß√µes de cores para o realce de sintaxe (Syntax Highlighting).
///
/// Mapeia a se√ß√£o `[syntax]` do arquivo `.clios.toml`.
/// Define as cores usadas enquanto o usu√°rio digita um comando.
#[derive(Debug, Deserialize, Clone)]
struct ConfigSyntax {
    /// Cor para comandos v√°lidos (encontrados no sistema ou builtins).
    /// * Padr√£o: "green"
    valid_cmd: Option<String>,
    
    /// Cor para comandos inv√°lidos (n√£o encontrados).
    /// * Padr√£o: "red"
    invalid_cmd: Option<String>, 
}
/// A Configura√ß√£o Raiz (Root) da Clios Shell.
///
/// Esta √© a estrutura principal que representa o arquivo `~/.clios.toml` inteiro.
/// O `serde` l√™ o arquivo e preenche estes campos automaticamente.
///
/// # Exemplo de Arquivo `.clios.toml`
/// ```toml
/// [prompt]
/// symbol = "‚ûú"
/// color = "purple"
///
/// [history]
/// max_entries = 5000
/// ```
#[derive(Debug, Deserialize, Clone)]
struct CliosConfig {
    /// Configura√ß√µes da se√ß√£o `[prompt]`.
    prompt: Option<ConfigPrompt>,
    
    /// Configura√ß√µes da se√ß√£o `[history]`.
    history: Option<ConfigHistory>,

    /// Configura√ß√µes da se√ß√£o `[syntax]`.
    syntax: Option<ConfigSyntax>,

    theme: Option<String>,
}

impl CliosConfig {
    /// Retorna a configura√ß√£o padr√£o (Default) caso o arquivo n√£o exista.
    ///
    /// # Valores Padr√£o
    /// * **Prompt:** S√≠mbolo `> `, Cor `blue`, Git `true`.
    /// * **History:** Arquivo `.clios_history`, 1000 entradas.
    fn default() -> Self {
        Self {
            prompt: Some(ConfigPrompt {
                symbol: Some("> ".to_string()),
                color: Some("blue".to_string()),
                show_git: Some(true),
                path_color: None,
                symbol_color: None,
            }),
            history: Some(ConfigHistory {
                file: Some(".clios_history".to_string()),
                max_entries: Some(1000),
            }),
            syntax: Some(ConfigSyntax {
                valid_cmd: Some("green".to_string()),
                invalid_cmd: Some("red".to_string()),
            }),
            theme: Some("powerline".to_string()), 
        }
    }
}

/// # CliosHelper (O C√©rebro Visual)
///
/// Esta estrutura √© exigida pelo `rustyline` para gerenciar a intera√ß√£o com o usu√°rio.
/// Ela agrupa todas as funcionalidades de "UX" (User Experience) do terminal.
///
/// ## Funcionalidades:
/// * **Completer:** Autocomplete de arquivos quando aperta TAB.
/// * **Hinter:** Sugest√£o cinza baseada no hist√≥rico.
/// * **Highlighter:** Colore o comando enquanto voc√™ digita (Verde/Vermelho).
#[derive(Helper, Hinter, Validator)]
struct CliosHelper {

    /// O sugestor baseado no hist√≥rico (HistoryHinter).
    #[rustyline(Hinter)]
    hinter: HistoryHinter,

    /// Armazena a vers√£o colorida do prompt (com c√≥digos ANSI).
    /// A anota√ß√£o `#[rustyline(Ignore)]` diz para o rustyline n√£o tentar completar
    /// ou validar esse campo, ele √© apenas para exibi√ß√£o.
    #[rustyline(Ignore)]
    colored_prompt: String,
    
    /// Cores para comandos v√°lidos e inv√°lidos.
    /// Usado na fun√ß√£o de highlight.
    #[rustyline(Ignore)]
    color_valid: String,   // Guarda o c√≥digo ANSI (ex: \x1b[32m)
    #[rustyline(Ignore)]
    color_invalid: String, // Guarda o c√≥digo ANSI (ex: \x1b[31m)
}

/// Implementa√ß√£o do tra√ßo `Highlighter` para colorir o texto.
impl Highlighter for CliosHelper {
    fn highlight_prompt<'b, 's: 'b, 'p: 'b>(&'s self, prompt: &'p str, default: bool) -> Cow<'b, str> {
        if default { Cow::Borrowed(&self.colored_prompt) } else { Cow::Borrowed(prompt) }
    }

    fn highlight<'l>(&self, line: &'l str, _pos: usize) -> Cow<'l, str> {
        let input = line.trim();
        if input.is_empty() { return Cow::Borrowed(line); }
        let first_word = input.split_whitespace().next().unwrap_or("");
        
        let is_valid = matches!(first_word, "cd" | "exit" | "pwd" | "alias" | "rhai" | "fg" | "export") || which(first_word).is_ok();

        if is_valid {
            // USA A COR CONFIGURADA DE SUCESSO
            Cow::Owned(format!("{}{}\x1b[0m", self.color_valid, line)) 
        } else {
            // USA A COR CONFIGURADA DE ERRO
            Cow::Owned(format!("{}{}\x1b[0m", self.color_invalid, line)) 
        }
    }

    fn highlight_char(&self, _line: &str, _pos: usize, _forced: CmdKind) -> bool { true }
}

/// # CliosShell (O Cora√ß√£o L√≥gico)
///
/// Esta estrutura mant√©m o **Estado Global** da sess√£o da shell.
/// Diferente do Helper (que cuida da tela), aqui ficam os dados que precisam
/// persistir entre um comando e outro.
struct CliosShell {
    /// Mapa de apelidos (Aliases). Ex: "update" -> "sudo apt update".
    aliases: HashMap<String, String>,

    /// O Motor (Engine) da linguagem de script Rhai.
    /// Ele sabe *como* compilar e executar scripts.
    rhai_engine: Engine, 

    /// O Escopo (Scope) da linguagem Rhai.
    /// Ele guarda *os dados* dos scripts (vari√°veis, constantes).
    /// O tempo de vida `'static` indica que ele √© dono dos pr√≥prios dados.
    rhai_scope: Scope<'static>,

    /// O C√≥digo de Sa√≠da (Exit Code) do √∫ltimo comando executado.
    /// * `0`: Sucesso.
    /// * `!= 0`: Erro (ex: 127 = comando n√£o encontrado).
    /// Fundamental para a l√≥gica de `&&` e `||`.
    last_exit_code: i32, 

    /// Armazena o caminho do diret√≥rio anterior.
    /// Usado para implementar o comando `cd -`.
    previous_dir: Option<std::path::PathBuf>, 

    /// Configura√ß√µes carregadas do arquivo TOML (ou padr√µes).
    /// Dispon√≠vel para toda a aplica√ß√£o consultar cores e prefer√™ncias.
    config: CliosConfig, // 

    // --- NOVO CAMPO NIVEL 12 ---
    // Guarda a "√Årvore de Sintaxe Abstrata" do script de init.
    // √â aqui que vivem as fun√ß√µes 'bom_dia', 'soma', etc.
    /// AST do script de inicializa√ß√£o (se houver).
    /// Permite reutilizar o c√≥digo compilado sem recompilar toda vez.
    /// Se `None`, significa que n√£o h√° script de init carregado.
    plugin_ast: Option<AST>,
}

impl CliosShell {
    /// Construtor: Inicializa a Shell e configura o motor de Script (Rhai).
    fn new() -> Self {
        // 1. Inicializa o motor Rhai APENAS UMA VEZ
        // O Engine √© pesado, ent√£o criamos ele no in√≠cio e reutilizamos.
        let mut engine = Engine::new();

        // --- INTEGRA√á√ÉO RUST <-> RHAI ---
        
        // Registra a fun√ß√£o 'shell_exec' dentro do Rhai.
        // Isso permite que scripts .rhai executem comandos do sistema.
        // Exemplo no script: shell_exec("ls -la");
        // Substitua o registro antigo por este:
        engine.register_fn("shell_exec", |cmd_str: &str| -> rhai::Map {
            let parts: Vec<&str> = cmd_str.split_whitespace().collect();
            let mut map = rhai::Map::new();

            if parts.is_empty() {
                map.insert("success".into(), false.into());
                return map;
            }
        
            match std::process::Command::new(parts[0]).args(&parts[1..]).output() {
                Ok(output) => {
                    let stdout = String::from_utf8_lossy(&output.stdout).trim().to_string();
                    let stderr = String::from_utf8_lossy(&output.stderr).trim().to_string();

                    // A M√ÅGICA: Mesclamos os dois em uma √∫nica string para o script
                    let combined = format!("{}{}", stdout, stderr).trim().to_string();
                
                    map.insert("success".into(), output.status.success().into());
                    map.insert("output".into(), combined.into()); // Usaremos 'output' no script
                    map
                },
                Err(e) => {
                    map.insert("success".into(), false.into());
                    map.insert("output".into(), e.to_string().into());
                    map
                }
            }
        });
        // --- N√çVEL 14: UI WIDGETS (INQUIRE) ---

        // 1. Confirma√ß√£o (Sim/N√£o)
        // Uso no Rhai: let resp = confirm("Deseja formatar o PC?");
        engine.register_fn("confirm", |prompt: &str| -> bool {
            match inquire::Confirm::new(prompt)
                .with_default(false)
                .prompt() {
                    Ok(true) => true,
                    Ok(false) => false,
                    Err(_) => false, // Se der erro (Ctrl+C), assume N√£o
                }
        });

        // 2. Menu de Sele√ß√£o
        // Uso no Rhai: let escolha = select("Qual linguagem?", ["Rust", "Python", "Go"]);
        engine.register_fn("select", |prompt: &str, options: Vec<rhai::Dynamic>| -> String {
            // Converte o Array do Rhai para Vec<String> do Rust
            let items: Vec<String> = options.iter()
                .map(|item| item.to_string())
                .collect();

            match inquire::Select::new(prompt, items).prompt() {
                Ok(choice) => choice,
                Err(_) => String::new(), // Retorna vazio se cancelar
            }
        });
        engine.register_fn("input", |prompt: &str| -> String {
             use std::io::{self, Write};
             print!("{}", prompt);
             let _ = io::stdout().flush();
             
             let mut buffer = String::new();
             let _ = io::stdin().read_line(&mut buffer);
             buffer.trim().to_string()
        });

        // --- N√çVEL 16: Conectividade (CLPM) ---
        
        // 1. Fun√ß√£o HTTP GET (Para baixar scripts)
        engine.register_fn("http_get", |url: &str| -> String {
            // Se voc√™ escolheu a Op√ß√£o 2 (rustls), isso funciona nativamente
            match reqwest::blocking::get(url) {
                Ok(resp) => {
                    if resp.status().is_success() {
                        resp.text().unwrap_or_else(|_| "Erro: Corpo vazio".to_string())
                    } else {
                        format!("Erro HTTP: {}", resp.status())
                    }
                },
                Err(e) => format!("Erro de Conex√£o: {}", e),
            }
        });

        // 2. Fun√ß√£o Salvar Arquivo (Para instalar o plugin)
        engine.register_fn("save_file", |path: &str, content: &str| -> bool {
             if let Some(parent) = std::path::Path::new(path).parent() {
                 let _ = std::fs::create_dir_all(parent);
             }
             std::fs::write(path, content).is_ok()
        });

        let loaded_config = load_toml_config();

        Self {
            aliases: HashMap::new(),
            rhai_engine: engine,      
            rhai_scope: Scope::new(), 
            plugin_ast: None,         // <--- INICIALIZA√á√ÉO DO N√çVEL 12
            last_exit_code: 0,        
            previous_dir: None,       
            config: loaded_config,    
        }
    }

    /// Executa o modo interativo dedicado ao Rhai (REPL).
    /// Semelhante ao digitar `python` no terminal.
    fn run_rhai_repl(&mut self) {
        println!("Entrando no modo Rhai (Digite 'exit' para sair)");
        
        // Criamos um editor simples s√≥ para esse modo (sem hist√≥rico compartilhado com o shell principal)
        let mut rl = rustyline::DefaultEditor::new().unwrap_or_else(|_| panic!("Falha ao iniciar REPL"));
        
        // Buffer para guardar comandos de v√°rias linhas
        let mut input_buffer = String::new();
        let mut open_braces = 0; // Contador de chaves { } para suporte a blocos multiline

        loop {
            // Se o buffer est√° vazio, prompt normal. Se tem coisa pendente (ex: if aberto), prompt "..."
            let prompt = if input_buffer.is_empty() { "rhai> " } else { "... " };

            match rl.readline(prompt) {
                Ok(line) => {
                    let trimmed = line.trim();

                    // Comando para sair
                    if trimmed == "exit" && input_buffer.is_empty() {
                        break;
                    }

                    // L√≥gica simples de multiline: conta { e }
                    // Se abriu mais do que fechou, continua pedindo input na pr√≥xima linha
                    open_braces += trimmed.matches('{').count();
                    let closed = trimmed.matches('}').count();
                    
                    // Prote√ß√£o para n√£o ficar negativo
                    if closed > open_braces {
                        open_braces = 0; 
                    } else {
                        open_braces -= closed;
                    }

                    // Adiciona a linha ao buffer
                    input_buffer.push_str(&line);
                    input_buffer.push('\n');

                    // Se todas as chaves est√£o fechadas, executa o c√≥digo acumulado!
                    if open_braces == 0 {
                        let result = self.rhai_engine.eval_with_scope::<rhai::Dynamic>(
                            &mut self.rhai_scope,
                            &input_buffer
                        );

                        match result {
                            Ok(val) => {
                                // S√≥ imprime se o retorno n√£o for vazio "()"
                                if val.type_name() != "()" {
                                    println!("=> {}", val);
                                }
                            }
                            Err(e) => println!("Erro: {}", e),
                        }
                        
                        // Limpa o buffer para o pr√≥ximo comando
                        input_buffer.clear();
                    }
                }
                Err(_) => break, // CTRL+C ou Erro sai do modo Rhai
            }
        }
    }   

    /// L√™ o arquivo de configura√ß√£o `~/.cliosrc` e executa linha por linha.
    /// Possui verifica√ß√£o de sintaxe para evitar crashes na inicializa√ß√£o.
    fn load_config(&mut self) {
        if let Ok(home) = env::var("HOME") {
            let config_path = Path::new(&home).join(".cliosrc");
            if config_path.exists() {
                if let Ok(file) = File::open(config_path) {
                    let reader = BufReader::new(file);
                    
                    for (i, line) in reader.lines().enumerate() {
                        if let Ok(l) = line {
                            let l = l.trim();
                            
                            // Pula linhas vazias ou coment√°rios
                            if !l.is_empty() && !l.starts_with('#') {
                                
                                // --- TESTE DE SINTAXE ANTES DE EXECUTAR ---
                                // Verifica se h√° aspas n√£o fechadas que quebrariam o parser
                                if shlex::split(l).is_none() {
                                    eprintln!("\x1b[1;31m[ERRO CONFIG]\x1b[0m .cliosrc Linha {}: Aspas n√£o fechadas.", i + 1);
                                    eprintln!("--> Conte√∫do: {}", l);
                                    continue; // Pula essa linha estragada
                                }

                                self.process_input_line(l);
                            }
                        }
                    }
                }
            }
        }
    }

    /// O C√©rebro da Execu√ß√£o: Processa uma linha de entrada bruta.
    /// Ordem de Opera√ß√µes:
    /// 1. Expans√£o de Subshells $()
    /// 2. Divis√£o L√≥gica (&&)
    /// 3. Expans√£o Recursiva de Aliases
    /// 4. Delega√ß√£o para execu√ß√£o
    /// N√çVEL 12: Carregador de Plugins (Compila√ß√£o √önica)
    /// L√™ um arquivo .rhai, compila para AST e guarda na mem√≥ria.
    /// N√çVEL 12.5: Carregador Cumulativo
    /// Agora ele SOMA o novo plugin aos existentes, em vez de substituir.
    fn load_plugin(&mut self, path: &str) {
        //println!("Compilando e mesclando plugin '{}'...", path);
        
        match self.rhai_engine.compile_file(path.into()) {
            Ok(new_ast) => {
                if let Some(ref mut existing_ast) = self.plugin_ast {
                    // SE J√Å TEM PLUGINS: Soma o novo ao antigo (Merge)
                    // O operador += combina as fun√ß√µes dos dois scripts
                    *existing_ast += new_ast;
                    //println!("Plugin mesclado com sucesso! Fun√ß√µes acumuladas.");
                } else {
                    // SE √â O PRIMEIRO: Apenas define
                    self.plugin_ast = Some(new_ast);
                    //println!("Primeiro plugin carregado.");
                }
            }
            Err(e) => eprintln!("Erro ao compilar plugin: {}", e),
        }
    }

    /// N√çVEL 12: Tenta executar uma fun√ß√£o do Plugin carregado.
    /// Retorna `true` se a fun√ß√£o existia e foi executada.
    
    fn try_execute_plugin(&mut self, cmd: &str, args: Vec<String>) -> bool {
        if let Some(ast) = &self.plugin_ast {
            let function_exists = ast.iter_functions().any(|f| f.name == cmd);

            if function_exists {
                // --- CORRE√á√ÉO DO N√çVEL 12 ---
                // Convertemos Vec<String> (Rust Puro) para Vec<Dynamic> (Rhai Array).
                // Assim o script entende que recebeu uma lista de textos.
                let rhai_args: Vec<rhai::Dynamic> = args.into_iter()
                    .map(|s| rhai::Dynamic::from(s))
                    .collect();

                // Chamamos a fun√ß√£o passando o Array inteiro como O PRIMEIRO argumento.
                // Na vis√£o do script: fn comando(lista_de_args)
                let result = self.rhai_engine.call_fn::<rhai::Dynamic>(
                    &mut self.rhai_scope,
                    ast,
                    cmd,
                    (rhai_args,) 
                );

                match result {
                    Ok(_) => return true,
                    Err(e) => println!("Erro no Plugin (Fun√ß√£o {}): {}", cmd, e),
                }
                return true; 
            }
        }
        false
    }
    /// N√çVEL 17: Auto-Loader de Plugins
    /// Varre a pasta ~/.clios_plugins e carrega todos os scripts .rhai automaticamente.
    fn load_auto_plugins(&mut self) {
        // 1. Localiza a pasta HOME
        let home = env::var("HOME").unwrap_or_else(|_| ".".to_string());
        let plugins_dir = Path::new(&home).join(".clios_plugins");

        // 2. Tenta ler o diret√≥rio
        if let Ok(entries) = fs::read_dir(plugins_dir) {
            for entry in entries.flatten() {
                let path = entry.path();
                
                // 3. Se for um arquivo e terminar em .rhai, carrega!
                if path.is_file() && path.extension().and_then(|s| s.to_str()) == Some("rhai") {
                    if let Some(path_str) = path.to_str() {
                        self.load_plugin(path_str);
                    }
                }
            }
        }
    }

    fn process_input_line(&mut self, input: &str) {
        // --- EXPANS√ÉO DE SUBSHELL ---
        // Resolve comandos dentro de $() antes de qualquer outra coisa
        let input_expanded = expand_subshells(input);

        // 1. DIVIDE POR && (N√≠vel Superior)
        // Usa o parser inteligente que respeita aspas
        let logical_parts = split_logical_and(&input_expanded);

        for part in logical_parts {
            // 2. EXPANS√ÉO DE ALIAS (String Level)
            // Agora expandimos "update" para "sudo apt update && sudo apt upgrade..."
            let expanded_part = expand_alias_string(&part, &self.aliases);

            // 3. RECURS√ÉO M√ÅGICA
            // Se a expans√£o mudou o texto E introduziu novos "&&" (comum em aliases complexos), 
            // processamos essa nova string recursivamente.
            if expanded_part != part && expanded_part.contains("&&") {
                self.process_input_line(&expanded_part);
                
                // Se deu erro na recurs√£o, para tudo (comportamento do &&)
                if self.last_exit_code != 0 { break; }
                continue;
            }
            
            // Se n√£o tem && novos, segue para execu√ß√£o normal do bloco
            let exit_code = self.execute_single_command_block(&expanded_part);
            self.last_exit_code = exit_code;

            // Se houve erro, o && impede a execu√ß√£o do pr√≥ximo comando
            if exit_code != 0 {
                break;
            }
        }
    }

    /// Executa um bloco de comando √∫nico (sem &&, mas pode ter Pipes |).
    /// Respons√°vel por: Parsing, Background (&), Rhai e Builtins.
    fn execute_single_command_block(&mut self, input: &str) -> i32 {
        // Divide por Pipes (|)
        let commands_raw: Vec<&str> = input.split('|').collect();

        // Caso Simples: Sem Pipes
        if commands_raw.len() == 1 {
            let raw_line = commands_raw[0].trim();
            
            // --- DETEC√á√ÉO DE BACKGROUND ---
            // Se termina com '&', rodamos em background
            let background = raw_line.ends_with('&');
            let clean_line = if background { raw_line[..raw_line.len()-1].trim() } else { raw_line };

            // Tokeniza√ß√£o (Divide a string em argumentos respeitando aspas)
            let mut tokens = match shlex::split(clean_line) {
                Some(t) => t,
                None => { 
                    eprintln!("\x1b[1;31m[ERRO SINTAXE]\x1b[0m Falha ao processar: '{}'", clean_line);
                    return 1; 
                }
            };
            
            // --- TRATAMENTO RHAI ---
            // Se for script Rhai inline (ex: rhai print(1))
            if tokens.first().map(|s| s.as_str()) == Some("rhai") {
                if let Some(idx) = clean_line.find("rhai") {
                    let code_part = clean_line[idx + 4..].trim(); 
                    tokens = vec!["rhai".to_string(), code_part.to_string()];
                }
            }

            // --- EXPANS√ïES FINAIS ---
            if tokens.first().map(|s| s.as_str()) != Some("rhai") {
                tokens = expand_variables(tokens); // $HOME, $USER
                tokens = expand_tilde(tokens);     // ~/Docs
                tokens = expand_globs(tokens);     // *.txt
            }

            if tokens.is_empty() { return 0; }
            let cmd_name = tokens[0].clone();
            let args = tokens[1..].to_vec(); // Argumentos para o plugin

            // --- AQUI EST√Å A MUDAN√áA DO N√çVEL 12 ---
            // ORDEM DE PRIORIDADE:
            // 1. Plugin (Fun√ß√£o Rhai carregada na mem√≥ria)
            // 2. Builtin (cd, exit, source...)
            // 3. Bin√°rio (ls, grep...)

            // 1. Tenta Plugin
            if self.try_execute_plugin(&cmd_name, args) {
                return 0; // Sucesso (assumimos 0 pois o Rhai tratou)
            }

            // Tenta rodar como comando interno (cd, exit, alias...)
            if self.handle_builtin(&tokens) {
                return 0; // Builtin assume sucesso
            } else {
                // Se n√£o √© builtin, √© um programa externo
                if background {
                    execute_job_control(tokens, true);
                    return 0; // Background retorna sucesso imediato
                } else {
                    // Executa programa normal (foreground)
                    return execute_pipeline(vec![tokens]);
                }
            }
        } else {
            // Caso Complexo: Pipeline (cmd1 | cmd2 | cmd3)
            let mut parsed_commands = Vec::new();
            
            for raw_cmd in commands_raw {
                // CORRE√á√ÉO NIVEL 11: 
                // Usamos expand_alias_string ANTES de dividir os tokens.
                // Isso permite que um alias dentro de um pipe se expanda corretamente.
                let expanded_cmd = expand_alias_string(raw_cmd, &self.aliases);

                let tokens = match shlex::split(&expanded_cmd) {
                    Some(t) => t,
                    None => { println!("Erro no pipe: aspas n√£o fechadas"); return 1; }
                };
                
                // Expans√µes restantes (Vari√°veis, Til, Globs)
                // Note que removemos a chamada antiga 'self.expand_alias(&mut tokens)'
                let tokens = expand_variables(tokens);
                let tokens = expand_tilde(tokens);
                let tokens = expand_globs(tokens);
                
                parsed_commands.push(tokens);
            }
            return execute_pipeline(parsed_commands);
        }
    }

    


    /// Executa comandos internos da Shell (Builtins).
    /// Retorna `true` se o comando foi tratado, `false` se n√£o era um builtin.
    fn handle_builtin(&mut self, tokens: &[String]) -> bool {
        if tokens.is_empty() { return false; }
        
        match tokens[0].as_str() {
            "cd" => {
                // Suporta: cd, cd path, cd -
                let target = if let Some(arg) = tokens.get(1) {
                    if arg == "-" {
                        // cd - : Volta para o diret√≥rio anterior
                        if let Some(prev) = &self.previous_dir {
                            println!("{}", prev.display());
                            Some(prev.clone())
                        } else {
                            println!("Erro: Nenhuma pasta anterior definida");
                            None
                        }
                    } else {
                        Some(Path::new(arg).to_path_buf())
                    }
                } else {
                    // cd sozinho vai para $HOME
                    env::var("HOME").ok().map(|p| Path::new(&p).to_path_buf())
                };

                if let Some(new_dir) = target {
                    // Salva o diret√≥rio atual antes de mudar (para o pr√≥ximo cd -)
                    if let Ok(current) = env::current_dir() {
                        self.previous_dir = Some(current);
                    }

                    if let Err(e) = env::set_current_dir(&new_dir) {
                        eprintln!("cd: {}", e);
                    }
                }
                true
            }
            "history" => {
                // L√™ o arquivo gerado pelo rustyline
                if let Ok(file) = File::open("history.txt") {
                    let reader = BufReader::new(file);
                    for (i, line) in reader.lines().enumerate() {
                        if let Ok(l) = line {
                            println!("{:5}  {}", i + 1, l);
                        }
                    }
                }
                true
            }
            // --- NOVO COMANDO N√çVEL 12 ---
            "source" | "load" => {
                if let Some(path) = tokens.get(1) {
                    self.load_plugin(path);
                } else {
                    println!("Uso: source <arquivo.rhai>");
                }

                true
            }
            "plugins" => {
        if let Some(ast) = &self.plugin_ast {
            println!("Comandos de Plugins Ativos:");
            println!("----------------------------");
            
            // O iter_functions() nos permite ver tudo o que foi compilado nos .rhai
            for func in ast.iter_functions() {
                // Filtramos fun√ß√µes que come√ßam com '_' (comumente usadas para l√≥gica interna)
                if !func.name.starts_with('_') {
                    // Mostra o nome da fun√ß√£o e quantos argumentos ela espera
                    println!("  ‚ûú {} ({} args)", func.name, func.params.len());
                }
            }
            println!("----------------------------");
        } else {
            println!("Nenhum plugin carregado na mem√≥ria.");
        }
        true
    }
            "pwd" => {
                if let Ok(path) = env::current_dir() { println!("{}", path.display()); }
                true
            }
            "exit" => { 
                std::process::exit(0); // Mata a shell
            }
            "alias" => {
                // Exibe ou cria aliases
                if tokens.len() < 2 {
                    for (name, val) in &self.aliases {
                        println!("{}='{}'", name, val);
                    }
                } else {
                    let arg = tokens[1..].join(" ");
                    if let Some((name, value)) = arg.split_once('=') {
                        self.aliases.insert(name.to_string(), value.to_string());
                    } else {
                        println!("Erro: Use alias nome=valor");
                    }
                }
                true
            }
            "rhai" => {
                // Ponte entre Shell e o interpretador Rhai
                let code = tokens.get(1).map(|s| s.as_str()).unwrap_or("").trim();
                
                if code.is_empty() {
                    // rhai (sem args) -> Modo REPL
                    self.run_rhai_repl();
                } else {
                    // rhai "print(1)" -> Execu√ß√£o One-Shot
                    let result = self.rhai_engine.eval_with_scope::<rhai::Dynamic>(
                        &mut self.rhai_scope,
                        code
                    );
                    match result {
                        Ok(valor) => {
                            if valor.type_name() != "()" {
                                println!("=> {}", valor);
                            }
                        }
                        Err(e) => println!("Erro Rhai: {}", e),
                    }
                }
                true 
            }
            "fg" => {
                // Traz um processo de background para foreground (N√≠vel 5)
                if let Some(pid_str) = tokens.get(1) {
                    if let Ok(pid_int) = pid_str.parse::<i32>() {
                        let pid = Pid::from_raw(pid_int);

                        // 1. Acorda o processo (SIGCONT)
                        let _ = signal::kill(pid, Signal::SIGCONT);

                        // 2. D√° o controle do terminal para ele (tcsetpgrp)
                        let _ = unistd::tcsetpgrp(std::io::stdin(), pid);

                        // 3. A Shell dorme e espera ele terminar ou pausar
                        let _ = wait::waitpid(pid, Some(WaitPidFlag::WUNTRACED));

                        // 4. O processo parou/morreu. A Shell pega o terminal de volta.
                        let shell_pgid = unistd::getpid();
                        let _ = unistd::tcsetpgrp(std::io::stdin(), shell_pgid);
                    }
                } else {
                    println!("Uso: fg <PID>");
                }
                true
            }
            "export" => {
                // Define vari√°veis de ambiente globais para a sess√£o
                if tokens.len() < 2 {
                    println!("Uso: export VAR=VALOR");
                } else {
                    let arg = tokens[1..].join(""); 
                    if let Some((key, value)) = arg.split_once('=') {
                        unsafe {std::env::set_var(key, value);}
                    } else {
                        println!("Erro: Use formato VAR=VALOR");
                    }
                }
                true
            }
            _ => false, // N√£o era um builtin, deixa o executor lidar
        }
    }
}

impl Completer for CliosHelper {
    type Candidate = Pair;

    fn complete(&self, line: &str, pos: usize, _ctx: &Context) -> rustyline::Result<(usize, Vec<Pair>)> {
        let (start, path_to_complete) = extract_word(line, pos);
        let mut matches = Vec::new();

        // 1. Identifica diret√≥rio base e o que estamos digitando
        // Se digitou "cd Des", dir=".", file_prefix="Des"
        // Se digitou "cd src/ma", dir="src", file_prefix="ma"
        let (dir, file_prefix) = if let Some(idx) = path_to_complete.rfind('/') {
            (&path_to_complete[..idx+1], &path_to_complete[idx+1..])
        } else {
            ("", path_to_complete)
        };

        // Resolve o caminho real para ler o disco
        let dir_path = if dir.is_empty() { ".".to_string() } else { dir.to_string() };
        
        // Tenta ler o diret√≥rio
        if let Ok(entries) = fs::read_dir(&dir_path) {
            for entry in entries.flatten() {
                if let Ok(name) = entry.file_name().into_string() {
                    // A M√ÅGICA DO SMART CASE:
                    // Comparamos tudo em min√∫sculo (lowercase)
                    if name.to_lowercase().starts_with(&file_prefix.to_lowercase()) {
                        
                        // Monta o resultado
                        let replacement = format!("{}{}", dir, name); // ex: src/Main.rs
                        
                        // Adiciona na lista de sugest√µes
                        matches.push(Pair {
                            display: name,       // O que aparece na lista (Main.rs)
                            replacement: replacement, // O que vai pra linha (src/Main.rs)
                        });
                    }
                }
            }
        }

        Ok((start, matches))
    }
}

// Fun√ß√£o auxiliar para pegar a palavra que est√° sendo digitada (separa por espa√ßos)
fn extract_word(line: &str, pos: usize) -> (usize, &str) {
    let line_before_cursor = &line[..pos];
    if let Some(last_space) = line_before_cursor.rfind(char::is_whitespace) {
        (last_space + 1, &line_before_cursor[last_space + 1..])
    } else {
        (0, line_before_cursor)
    }
}
/// Converte um nome de cor leg√≠vel (ex: "red") para seu c√≥digo ANSI correspondente.
///
/// Esta fun√ß√£o √© usada para traduzir as configura√ß√µes do usu√°rio no arquivo TOML
/// para os caracteres de escape que o terminal entende.
///
/// # Cores Suportadas
/// * red, green, yellow, blue, purple, cyan, white.
/// * Qualquer outra string retorna o c√≥digo de reset/padr√£o.
fn get_color_ansi(color_name: &str) -> String {
    match color_name {
        "red"     => "\x1b[31m".to_string(),
        "green"   => "\x1b[32m".to_string(),
        "yellow"  => "\x1b[33m".to_string(),
        "blue"    => "\x1b[34m".to_string(),
        "purple"  => "\x1b[35m".to_string(),
        "cyan"    => "\x1b[36m".to_string(),
        "white"   => "\x1b[37m".to_string(),
        _         => "\x1b[0m".to_string(), // Default (sem cor)
    }
}
// --- FUN√á√ÉO MAIN ---
// O ponto de entrada do programa.
// Retorna um Result do rustyline para tratar erros fatais de I/O na inicializa√ß√£o.
fn main() -> rustyline::Result<()> {
    // 1. Inicializa o estado da Shell
    // Cria a struct CliosShell com o motor Rhai pronto.
    let mut shell = CliosShell::new();
    // N√çVEL 17: Carrega plugins autom√°ticos da pasta ~/.clios_plugins
    shell.load_auto_plugins();
    // Carrega configura√ß√µes do usu√°rio (~/.cliosrc)
    // Isso define aliases e roda comandos de inicializa√ß√£o antes de mostrar o prompt.
    shell.load_config(); 

    // --- BLOCO DE ARGUMENTOS DE LINHA DE COMANDO ---
    // Verifica se o usu√°rio passou argumentos (ex: clios script.rhai ou clios -c "ls")
    let args: Vec<String> = env::args().collect();

    if args.len() > 1 {
        // CASO A: Flag -c (Comando √∫nico)
        // √ötil para scripts externos chamarem o clios: `clios -c "echo oi"`
        if args[1] == "-c" {
            if args.len() > 2 {
                let command = &args[2];
                // Prote√ß√£o contra crashes (Panic Catch) mesmo no modo n√£o-interativo
                let _ = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
                    shell.process_input_line(command);
                }));
            } else {
                eprintln!("Erro: -c requer um comando entre aspas");
                std::process::exit(1);
            }
            return Ok(()); // Sai do programa ap√≥s executar
        }
        
        // CASO B: Script Rhai (.rhai)
        // Detecta pela extens√£o se √© um script avan√ßado
        if args[1].ends_with(".rhai") {
            println!("--- Executando Script Rhai ---");
            if let Err(e) = run_rhai_script(&args[1]) {
                eprintln!("Erro no script Rhai: {}", e);
                std::process::exit(1);
            }
            return Ok(()); 
        }

        // CASO C: Script Shell comum (estilo Bash)
        // L√™ um arquivo de texto e executa linha por linha
        let script_path = Path::new(&args[1]);
        if let Ok(file) = File::open(script_path) {
            let reader = BufReader::new(file);
            for line in reader.lines() {
                if let Ok(l) = line {
                    // Ignora linhas vazias e coment√°rios (#)
                    if !l.trim().is_empty() && !l.starts_with('#') {
                        let _ = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
                            shell.process_input_line(&l);
                        }));
                    }
                }
            }
            return Ok(());
        } else {
            eprintln!("Erro: Arquivo n√£o encontrado '{}'", args[1]);
            std::process::exit(1);
        }
    }
    // --- [FIM DO BLOCO DE ARGUMENTOS] ---
    
    // 2. Configura Rustyline (Interface Interativa) - MODO SEGURO
    
    // Extrai configura√ß√µes de hist√≥rico com fallback (se falhar, usa padr√£o)
    let (hist_file, max_entries) = if let Some(h) = &shell.config.history {
        (
            h.file.as_deref().unwrap_or(".clios_history"),
            h.max_entries.unwrap_or(1000)
        )
    } else {
        (".clios_history", 1000) // Padr√µes se a se√ß√£o [history] n√£o existir
    };

    // Configura o Rustyline com o limite do usu√°rio
    let config = rustyline::Config::builder()
        .auto_add_history(false) // Adicionamos manualmente ap√≥s valida√ß√£o
        .max_history_size(max_entries).unwrap()
        .build();
    // 1. Pega as cores do TOML (COM SEGURAN√áA ANTICRASH)
    // Usamos um 'if let' para verificar se a se√ß√£o existe.
    // Se existir, pegamos as cores. Se n√£o, usamos os padr√µes.
    let (valid_str, invalid_str) = if let Some(syntax) = &shell.config.syntax {
        (
            syntax.valid_cmd.as_deref().unwrap_or("green"),
            syntax.invalid_cmd.as_deref().unwrap_or("red")
        )
    } else {
        ("green", "red") // Defaults se a se√ß√£o [syntax] n√£o estiver no arquivo
    };

    // 2. Cria o Helper injetando as cores convertidas
    let h = CliosHelper {
        
        hinter: HistoryHinter {},
        colored_prompt: String::new(),
        
        // Passamos os c√≥digos ANSI prontos
        color_valid: get_color_ansi(valid_str),
        color_invalid: get_color_ansi(invalid_str),
    };
    // Inicializa o Editor com nosso Helper customizado
    let mut rl: Editor<CliosHelper, DefaultHistory> = Editor::with_config(config)?;
    rl.set_helper(Some(h));

    // Define o caminho do hist√≥rico
    let history_path = env::var("HOME")
        .map(|p| Path::new(&p).join(hist_file))
        .unwrap_or_else(|_| Path::new(hist_file).to_path_buf());// Pega o HOME ou usa o nome simples

    // Carrega o hist√≥rico de comandos anteriores
    if rl.load_history(&history_path).is_err() { 
        // Se falhar (primeira vez usando), mostra mensagem de boas-vindas
        println!("Bem-vindo ao Clios Shell v1.0 (Final Release) "); 
        println!("Digite 'create' para iniciar um projeto ou 'rhai' para scripts.");
    }

    // --- LOOP PRINCIPAL (REPL) ---
    // Aqui √© onde a m√°gica acontece: L√™ -> Avalia -> Imprime -> Repete
    // Vari√°vel de controle de tema (come√ßa com o da config ou powerline)
    // Vari√°vel de controle de tema (come√ßa com o da config ou powerline)
    let mut current_theme = shell.config.theme.clone().unwrap_or("powerline".to_string());

    // --- LOOP PRINCIPAL ---
    loop {
        let final_prompt;
        
        if current_theme == "powerline" {
            // --- OP√á√ÉO A: MODO POWERLINE (Novo) ---
            let segments = get_powerline_segments(&shell);
            let prompt_bar = build_powerline_prompt(segments);
            // Prompt na mesma linha com seta verde
            final_prompt = format!("{} \x1b[1;32m‚ùØ\x1b[0m ", prompt_bar); 

        } else {
            // --- OP√á√ÉO B: MODO CL√ÅSSICO CUSTOMIZ√ÅVEL (Restaurado) ---
            // Esta √© a sua l√≥gica original que l√™ o [prompt] do TOML
            
            let current_dir = env::current_dir().unwrap_or_default();
            let dir_display = current_dir.display();

            // 1. Pega configura√ß√µes do usu√°rio
            let (symbol, default_color, path_color_cfg, symbol_color_cfg, show_git) = 
                if let Some(p) = &shell.config.prompt {
                    (
                        p.symbol.as_deref().unwrap_or(">"),
                        p.color.as_deref().unwrap_or("blue"),
                        p.path_color.as_deref(),
                        p.symbol_color.as_deref(),
                        p.show_git.unwrap_or(true)
                    )
                } else {
                    (">", "blue", None, None, true)
                };

            // 2. Resolve as Cores
            let path_ansi = get_color_ansi(path_color_cfg.unwrap_or(default_color));
            let arrow_ansi = get_color_ansi(symbol_color_cfg.unwrap_or(default_color));

            // 3. L√≥gica do Git (s√≥ se estiver ativado)
            let (_, git_color) = if show_git {
                 if let Some(branch) = get_git_branch() {
                    (format!(" ({})", branch), format!(" (\x1b[1;35m{}\x1b[0m)", branch))
                } else {
                    (String::new(), String::new())
                }
            } else {
                (String::new(), String::new())
            };

            // 4. Monta a seta (verifica erro anterior)
            let arrow_colored = if shell.last_exit_code == 0 {
                format!("{}{}\x1b[0m ", arrow_ansi, symbol)
            } else {
                format!("\x1b[1;31m[{}]>\x1b[0m ", shell.last_exit_code)
            };

            // 5. Montagem Final do Prompt Cl√°ssico
            // Formato: clios:/caminho (git)> 
            final_prompt = format!(
                "{}{}{}:{}{}\x1b[0m{}", 
                "", // prefixo vazio
                path_ansi, 
                "clios", // ou user
                dir_display, 
                git_color,
                arrow_colored
            );
        }

        // --- FIM DA ESCOLHA DE TEMA ---

        // Injeta no Rustyline
        if let Some(helper) = rl.helper_mut() { 
            helper.colored_prompt = final_prompt.clone(); 
        }

        match rl.readline(&final_prompt) {
            Ok(line) => {
                let input = line.trim();
                if input.is_empty() { continue; }

                // Comandos de troca de tema em tempo real
                if input == "theme classic" {
                    current_theme = "classic".to_string();
                    continue;
                }
                if input == "theme powerline" {
                    current_theme = "powerline".to_string();
                    continue;
                }

                // Salva hist√≥rico
                let _ = rl.add_history_entry(input);
                let _ = rl.append_history(&history_path);

                // Executa
                let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
                    shell.process_input_line(input);
                }));
                if let Err(_) = result { eprintln!("\n(!) Panic recuperado."); }
            }
            Err(ReadlineError::Interrupted) => { println!("CTRL-C"); continue; }
            Err(ReadlineError::Eof) => { break; }
            Err(_) => { break; }
        }
    }
    // Salva o hist√≥rico no arquivo ao sair
    rl.save_history(&history_path)?;
    Ok(())
}

// --- FUN√á√ïES UTILIT√ÅRIAS ---
// Fun√ß√µes auxiliares que n√£o dependem do estado interno da Shell (stateless).

/// Expans√£o Recursiva de Vari√°veis de Ambiente (N√≠vel 10).
///
/// Varre cada token procurando por padr√µes `$VAR` ou `${VAR}` e substitui
/// pelo valor real do sistema operacional. Funciona inclusive no meio de strings.
///
/// # Exemplo
/// * Entrada: `echo Backup_$USER.tar.gz`
/// * Sa√≠da: `echo Backup_pedro.tar.gz`
fn expand_variables(tokens: Vec<String>) -> Vec<String> {
    tokens.into_iter().map(|token| {
        // Otimiza√ß√£o: Se n√£o tem '$', retorna o token original imediatamente
        if !token.contains('$') {
            return token;
        }

        let mut output = String::new();
        let mut chars = token.chars().peekable();

        while let Some(c) = chars.next() {
            if c == '$' {
                // In√≠cio de uma vari√°vel.
                // Detecta se √© formato estendido ${VAR} ou simples $VAR
                let mut var_name = String::new();
                let mut is_bracketed = false;

                if let Some(&'{') = chars.peek() {
                    is_bracketed = true;
                    chars.next(); // Consome '{'
                }

                // L√™ o nome da vari√°vel (Letras, N√∫meros ou Underline)
                // Ex: "HOME", "USER_ID", "VAR1"
                while let Some(&next_c) = chars.peek() {
                    if next_c.is_alphanumeric() || next_c == '_' {
                        var_name.push(next_c);
                        chars.next();
                    } else {
                        // Se encontrou um caractere inv√°lido (ex: / ou .), acabou o nome.
                        if is_bracketed && next_c == '}' {
                            chars.next(); // Consome '}' final
                        }
                        break;
                    }
                }
                
                // Se extraiu um nome v√°lido, busca no Sistema Operacional
                if !var_name.is_empty() {
                    if let Ok(val) = env::var(&var_name) {
                        output.push_str(&val); // Sucesso: Substitui pelo valor
                    } else {
                        // Vari√°vel n√£o existe? O padr√£o Bash √© substituir por vazio ("").
                        // N√≥s fazemos o mesmo (n√£o fazemos nada aqui).
                    }
                } else {
                    // Era apenas um "$" solto sem nome depois. Mant√©m literal.
                    output.push('$');
                }
            } else {
                output.push(c); // Caractere normal
            }
        }
        output
    }).collect()
}

/// Expans√£o de "Globs" (Curingas de Arquivo).
///
/// Utiliza a crate `glob` para transformar padr√µes como `*.rs` ou `src/*`
/// em uma lista de arquivos reais do disco.
///
/// # Comportamento
/// * Se encontrar arquivos: Substitui o token pela lista de arquivos.
/// * Se N√ÉO encontrar: Mant√©m o token original (ex: `rm *.txt` falha se n√£o houver txt).
fn expand_globs(tokens: Vec<String>) -> Vec<String> {
    let mut expanded_tokens = Vec::new();
    for token in tokens {
        // S√≥ ativa o globbing se tiver caracteres m√°gicos
        if token.contains('*') || token.contains('?') {
            match glob(&token) {
                Ok(paths) => {
                    let mut found = false;
                    for entry in paths {
                        if let Ok(p) = entry {
                            if let Some(s) = p.to_str() { 
                                expanded_tokens.push(s.to_string()); 
                                found = true; 
                            }
                        }
                    }
                    // Se o padr√£o n√£o bateu com nada, mant√©m o original
                    if !found { expanded_tokens.push(token); }
                }
                Err(_) => { expanded_tokens.push(token); }
            }
        } else { 
            expanded_tokens.push(token); 
        }
    }
    expanded_tokens
}
/// Analisa e processa operadores de redirecionamento de I/O (N√≠vel 9).
///
/// Esta fun√ß√£o percorre a lista de tokens procurando por operadores especiais
/// de redirecionamento. Quando encontra, ela abre o arquivo correspondente
/// e o remove da lista de argumentos do comando.
///
/// # Operadores Suportados
/// * `>`   : Redireciona **STDOUT** (Sobrescreve o arquivo).
/// * `>>`  : Redireciona **STDOUT** (Adiciona ao final do arquivo - Append).
/// * `2>`  : Redireciona **STDERR** (Sobrescreve o arquivo).
/// * `2>>` : Redireciona **STDERR** (Adiciona ao final do arquivo - Append).
///
/// # Retorno
/// Retorna uma tupla `(Vec<String>, Option<File>, Option<File>)`:
/// 1. **Argumentos Limpos:** O comando sem os s√≠mbolos de redirecionamento.
/// 2. **Arquivo Sa√≠da:** O arquivo aberto para onde vai o stdout (se houver).
/// 3. **Arquivo Erro:** O arquivo aberto para onde vai o stderr (se houver).
fn parse_redirection(tokens: &[String]) -> (Vec<String>, Option<File>, Option<File>) {
    let mut clean = Vec::new();    // Argumentos do comando (ex: "ls", "-l")
    let mut stdout_file = None;    // Arquivo para > ou >>
    let mut stderr_file = None;    // Arquivo para 2> ou 2>>
    
    // Usamos um iterador 'peekable' (que permite espiar o pr√≥ximo item)
    // mas aqui usamos apenas next() manual para consumir o nome do arquivo.
    let mut iter = tokens.iter().peekable();
    
    while let Some(t) = iter.next() {
        match t.as_str() {
            // Sa√≠da Padr√£o (Overwrite): Abre com truncate=true (zera o arquivo)
            ">" => if let Some(f) = iter.next() {
                if let Ok(o) = OpenOptions::new().write(true).create(true).truncate(true).open(f) { 
                    stdout_file = Some(o); 
                }
            },
            // Sa√≠da Padr√£o (Append): Abre com append=true (mant√©m conte√∫do antigo)
            ">>" => if let Some(f) = iter.next() {
                if let Ok(o) = OpenOptions::new().write(true).create(true).append(true).open(f) { 
                    stdout_file = Some(o); 
                }
            },
            // Sa√≠da de Erro (Overwrite) - N√≠vel 9
            "2>" => if let Some(f) = iter.next() {
                if let Ok(o) = OpenOptions::new().write(true).create(true).truncate(true).open(f) { 
                    stderr_file = Some(o); 
                }
            },
            // Sa√≠da de Erro (Append) - N√≠vel 9
            "2>>" => if let Some(f) = iter.next() {
                if let Ok(o) = OpenOptions::new().write(true).create(true).append(true).open(f) { 
                    stderr_file = Some(o); 
                }
            },
            // Token normal (n√£o √© operador): Adiciona na lista de execu√ß√£o
            _ => clean.push(t.clone()),
        }
    }
    (clean, stdout_file, stderr_file)
}
/// Executa uma "Pipeline" de comandos (ex: `ls | grep txt | wc -l`).
///
/// Esta √© a fun√ß√£o que realmente faz os programas rodarem. Ela gerencia:
/// 1. **Pipes:** Conecta a sa√≠da de um comando na entrada do pr√≥ximo.
/// 2. **Redirecionamento:** Conecta arquivos (`>`, `2>`) se necess√°rio.
/// 3. **Exit Codes:** Captura se o comando deu certo ou errado.
///
/// # Como funciona (The Daisy Chain)
/// Em um pipe `A | B | C`:
/// * **A**: Stdin = Teclado, Stdout = Pipe(A->B)
/// * **B**: Stdin = Pipe(A->B), Stdout = Pipe(B->C)
/// * **C**: Stdin = Pipe(B->C), Stdout = Tela

fn execute_pipeline(commands: Vec<Vec<String>>) -> i32 {
    let mut prev_cmd: Option<Child> = None; // Guarda o processo anterior (para pegar o cano dele)
    let mut final_exit_code = 0;

    for (i, tokens) in commands.iter().enumerate() {
        if tokens.is_empty() { continue; }
        
        // 1. Separa o comando dos redirecionamentos de arquivo
        // Ex: ["ls", ">", "file.txt"] vira args=["ls"], outfile=Some(file.txt)
        let (mut args, outfile, errfile) = parse_redirection(tokens);
        
        if args.is_empty() { continue; } // Prote√ß√£o contra comando vazio
        let cmd = args.remove(0);

        // 2. Configura√ß√£o do STDIN (De onde vem os dados?)
        let stdin = if let Some(mut child) = prev_cmd { 
            // Se existe um comando anterior, roubamos a sa√≠da dele para ser nossa entrada
            Stdio::from(child.stdout.take().unwrap()) 
        } else { 
            // Se √© o primeiro comando, l√™ do teclado
            Stdio::inherit() 
        };
        
        // 3. Configura√ß√£o do STDOUT (Para onde v√£o os dados?)
        let stdout = if let Some(f) = outfile { 
            // Prioridade 1: Arquivo (>)
            Stdio::from(f) 
        } else if i < commands.len() - 1 { 
            // Prioridade 2: Pipe para o pr√≥ximo comando (|)
            Stdio::piped() 
        } else { 
            // Prioridade 3: Tela (Se for o √∫ltimo comando)
            Stdio::inherit() 
        };

        // 4. Configura√ß√£o do STDERR (Para onde v√£o os erros?)
        // Erros geralmente n√£o passam pelo Pipe, eles vazam para a tela
        // a menos que usemos '2>' para redirecionar explicitamente.
        let stderr = if let Some(f) = errfile {
            Stdio::from(f)
        } else {
            Stdio::inherit() // Mostra o erro na tela
        };

        // 5. Executa (Spawn)
        // Cria o processo filho com as configura√ß√µes de canais definidas acima.
        match Command::new(&cmd).args(&args)
            .stdin(stdin)
            .stdout(stdout)
            .stderr(stderr) 
            .spawn() {
            Ok(child) => prev_cmd = Some(child), // Sucesso: salva este filho como 'anterior' para o pr√≥ximo loop
            Err(e) => { 
                eprintln!("Erro: '{}': {}", cmd, e); 
                return 127; // C√≥digo padr√£o POSIX para "Command Not Found"
            }
        }
    }

    // 6. Espera Final
    // Em um pipeline, a shell s√≥ espera o √öLTIMO comando terminar.
    // Os anteriores morrem naturalmente quando o pipe fecha ou quando terminam o trabalho.
    if let Some(mut final_child) = prev_cmd { 
        if let Ok(status) = final_child.wait() {
            // Pega o c√≥digo de sa√≠da (ex: 0 = Sucesso, 1 = Erro)
            final_exit_code = status.code().unwrap_or(1);
        }
    }
    
    final_exit_code
}
/// Inicializa e executa um script Rhai externo (.rhai).
///
/// Diferente do modo interativo, esta fun√ß√£o cria um motor "limpo" e novo.
/// Isso garante que scripts rodem em um ambiente isolado, sem poluir
/// ou depender das vari√°veis da sess√£o atual da shell.
///
/// # Funcionalidades Injetadas no Script
/// Para que o script n√£o seja in√∫til, injetamos duas fun√ß√µes nativas do Rust nele:
/// 1. `shell_exec(cmd)`: Permite rodar comandos do sistema (ex: `ls`, `git`).
/// 2. `input(prompt)`: Permite pedir dados ao usu√°rio (interatividade).
fn run_rhai_script(path: &str) -> Result<(), Box<EvalAltResult>> {
    let mut engine = Engine::new();

    engine.register_fn("shell_exec", |cmd_str: &str| -> rhai::Map {
        let parts: Vec<&str> = cmd_str.split_whitespace().collect();
        let mut map = rhai::Map::new();

        if parts.is_empty() {
            map.insert("success".into(), false.into());
            return map;
        }

        match std::process::Command::new(parts[0]).args(&parts[1..]).output() {
            Ok(output) => {
                let stdout = String::from_utf8_lossy(&output.stdout).trim().to_string();
                let stderr = String::from_utf8_lossy(&output.stderr).trim().to_string();

                // A M√ÅGICA: Mesclamos os dois em uma √∫nica string para o script
                let combined = format!("{}{}", stdout, stderr).trim().to_string();

                map.insert("success".into(), output.status.success().into());
                map.insert("output".into(), combined.into()); // Usaremos 'output' no script
                map
            },
            Err(e) => {
                map.insert("success".into(), false.into());
                map.insert("output".into(), e.to_string().into());
                map
            }
        }
    });

    // 2. Registra 'input'
    // Permite criar wizards interativos (ex: "Qual o nome do projeto?").
    engine.register_fn("input", |prompt: &str| -> String {
        use std::io::{self, Write};
        print!("{}", prompt);
        let _ = io::stdout().flush(); // Garante que o texto apare√ßa antes de travar no read_line
        
        let mut buffer = String::new();
        let _ = io::stdin().read_line(&mut buffer);
        buffer.trim().to_string()
    });

    // 3. Carrega e roda o arquivo do disco
    engine.run_file(path.into())?;

    Ok(())
}

/// Expans√£o de "Command Substitution" ou Subshell `$()`.
///
/// Detecta padr√µes `$(comando)` dentro de uma string, executa o comando ocultamente,
/// captura a sa√≠da (STDOUT) e substitui o padr√£o pelo resultado.
///
/// # Exemplo
/// * Entrada: `echo Hoje √© $(date)`
/// * Execu√ß√£o: Roda `date`, captura "S√°b Dez 14..."
/// * Sa√≠da: `echo Hoje √© S√°b Dez 14...`
///
/// # Algoritmo (Parentheses Counting)
/// Diferente de Regex simples, este parser conta o n√≠vel de aninhamento.
/// Isso permite comandos complexos como: `echo $(echo $(date))`

fn expand_subshells(input: &str) -> String {
    let mut output = String::new();
    let mut chars = input.chars().peekable();

    while let Some(c) = chars.next() {
        if c == '$' {
            // Verifica se o pr√≥ximo char √© '('
            if let Some(&'(') = chars.peek() {
                chars.next(); // Consome o '(' inicial
                
                // Captura o conte√∫do interno
                let mut nested = 0; // Contador de aninhamento
                let mut inner = String::new();
                let mut closed = false;

                // Loop para capturar tudo at√© o par√™ntese de fechamento correspondente
                while let Some(inner_c) = chars.next() {
                    if inner_c == '(' {
                        nested += 1; // Aprofunda um n√≠vel
                        inner.push(inner_c);
                    } else if inner_c == ')' {
                        if nested > 0 {
                            nested -= 1; // Volta um n√≠vel
                            inner.push(inner_c);
                        } else {
                            closed = true; // Achou o fechamento final!
                            break; 
                        }
                    } else {
                        inner.push(inner_c);
                    }
                }

                if closed {
                    // Executa o comando capturado e coloca o resultado no lugar
                    let result = execute_and_capture(&inner);
                    output.push_str(&result);
                } else {
                    // Se o loop acabou e n√£o fechou, devolve o texto original
                    // (Significa que era uma string quebrada ou inv√°lida)
                    output.push_str("$(");
                    output.push_str(&inner);
                }
                continue;
            }
        }
        output.push(c);
    }
    output
}

/// Executa um comando e captura sua sa√≠da (STDOUT) como string.
/// Esta fun√ß√£o √© usada pela `expand_subshells` para resolver `$(...)`.
///
/// # O Truque de Mestre (Self-Execution)
/// Se o comando dentro do subshell for um script `rhai` (ex: `$(rhai print(1+1))`),
/// a Clios n√£o tenta rodar isso internamente. Em vez disso:
/// 1. Ela descobre onde est√° seu pr√≥prio bin√°rio (`env::current_exe`).
/// 2. Ela cria um **novo processo filho** de si mesma.
/// 3. Passa o c√≥digo Rhai via flag `-c`.
///
/// Isso garante isolamento total e evita conflitos de mem√≥ria no Rhai Engine.
fn execute_and_capture(cmd_line: &str) -> String {
    let tokens = match shlex::split(cmd_line) {
        Some(t) => t,
        None => return String::new(),
    };
    if tokens.is_empty() { return String::new(); }

    let prog = &tokens[0];
    let args = &tokens[1..];

    // TRUQUE DE MESTRE: Recurs√£o de Processo
    if prog == "rhai" {
        if let Ok(myself) = env::current_exe() {
            let output = Command::new(myself)
                .arg("-c") // Chama: clios -c "codigo rhai"
                .arg(cmd_line)
                .output();

            return match output {
                Ok(out) => String::from_utf8_lossy(&out.stdout).trim().to_string(),
                Err(_) => String::new(),
            };
        }
    }

    // Execu√ß√£o normal (ls, date, git...)
    let output = Command::new(prog)
        .args(args)
        .output();

    match output {
        Ok(out) => String::from_utf8_lossy(&out.stdout).trim().to_string(),
        Err(_) => String::new(),
    }
}

/// Execu√ß√£o de baixo n√≠vel com controle total de Processos (Job Control - N√≠vel 5).
///
/// Diferente do `execute_pipeline` (que usa a std lib), esta fun√ß√£o usa `nix` para
/// chamar `fork` e `exec` manualmente. Isso √© necess√°rio para manipular
/// **Process Groups** e definir quem √© o "dono" do terminal.
///
/// # A Dan√ßa do Terminal (Terminal Handoff)
/// Para que o `Ctrl+C` v√° para o processo certo, precisamos transferir a posse
/// do terminal (STDIN) da Shell para o Processo Filho.
///
/// 1. **Shell:** Ignora `SIGTTOU` (para n√£o ser suspensa ao mexer no terminal).
/// 2. **Fork:** Cria uma c√≥pia do processo.
/// 3. **Pai & Filho:** Ambos tentam setar o `setpgid` (para evitar race conditions).
/// 4. **Pai:** D√° o terminal pro filho (`tcsetpgrp`) e espera (`waitpid`).
/// 5. **Pai:** Quando o filho morre/para, pega o terminal de volta.

fn execute_job_control(tokens: Vec<String>, background: bool) {
    // Seguran√ßa: Ignorar SIGTTOU na shell para n√£o sermos pausados ao mudar o dono do terminal
    unsafe { signal::signal(Signal::SIGTTOU, SigHandler::SigIgn) }.unwrap();

    // O "Fork" divide a linha do tempo em duas: Pai (Shell) e Filho (Comando)
    match unsafe { unistd::fork() } {
        Ok(unistd::ForkResult::Parent { child, .. }) => {
            // --- C√ìDIGO DO PAI (SHELL) ---
            let pgid = child; // O ID do grupo ser√° o mesmo do PID do filho

            // A DAN√áA: Garante que o filho tenha seu pr√≥prio grupo
            let _ = unistd::setpgid(child, pgid);

            if !background {
                // Se N√ÉO √© background, d√° o terminal para o filho
                let _ = unistd::tcsetpgrp(std::io::stdin(), pgid);

                // Espera o filho morrer ou pausar (WUNTRACED pega Ctrl+Z)
                match wait::waitpid(child, Some(WaitPidFlag::WUNTRACED)) {
                    Ok(WaitStatus::Stopped(_, _sig)) => {
                        println!("\n[Job {}] Pausado (Ctrl+Z)", child);
                    }
                    Ok(WaitStatus::Signaled(_, sig, _)) => {
                        println!("\n[Job {}] Morto pelo sinal: {:?}", child, sig);
                    }
                    _ => {} // Terminou normal
                }

                // O filho terminou/pausou. A Shell pega o controle de volta.
                let shell_pgid = unistd::getpid();
                let _ = unistd::tcsetpgrp(std::io::stdin(), shell_pgid);
            } else {
                // Se √© background, apenas avisa o usu√°rio e n√£o espera
                println!("[Background Job {}]", child);
            }
        }
        Ok(unistd::ForkResult::Child) => {
            // --- C√ìDIGO DO FILHO (COMANDO) ---
            let pid = unistd::getpid();
            // A DAN√áA: Filho tamb√©m define seu grupo (seguran√ßa contra race condition)
            let _ = unistd::setpgid(pid, pid);

            if !background {
                // Filho toma posse do terminal
                let _ = unistd::tcsetpgrp(std::io::stdin(), pid);
            }

            // Restaura os sinais para o padr√£o (para que Ctrl+C funcione no filho)
            unsafe { signal::signal(Signal::SIGTTOU, SigHandler::SigDfl) }.unwrap();
            unsafe { signal::signal(Signal::SIGINT, SigHandler::SigDfl) }.unwrap();

            // Substitui a imagem do processo atual pelo programa novo (exec)
            use std::os::unix::process::CommandExt; 

            let err = Command::new(&tokens[0])
                .args(&tokens[1..])
                .exec();

            // Se o exec retornar, √© porque deu erro (o programa n√£o existe)
            eprintln!("Erro ao executar '{}': {}", tokens[0], err);
            std::process::exit(1);
        }
        Err(_) => println!("Fork falhou - Sistema sem recursos"),
    }
}

/// Expans√£o do Til (`~`).
///
/// No Linux, `~` √© um atalho para a pasta HOME do usu√°rio.
/// Esta fun√ß√£o substitui tokens que come√ßam com `~` pelo caminho absoluto.
///
/// # Exemplos
/// * `cd ~` -> `cd /home/pedro`
/// * `ls ~/Downloads` -> `ls /home/pedro/Downloads`
fn expand_tilde(tokens: Vec<String>) -> Vec<String> {
    // Tenta pegar a home do usu√°rio. Se falhar, usa "/"
    let home = env::var("HOME").unwrap_or_else(|_| "/".to_string());
    
    tokens.into_iter().map(|t| {
        if t == "~" {
            home.clone() // "~" vira "/home/pedro"
        } else if t.starts_with("~/") {
            // "~/scripts" vira "/home/pedro/scripts"
            // Remove o "~" (primeiro char) e cola a home no lugar
            format!("{}{}", home, &t[1..]) 
        } else {
            t
        }
    }).collect()
}

/// Detecta a Branch do Git para o Prompt (N√≠vel 7).
///
/// Executa `git branch --show-current` em um processo separado.
/// O `stderr` √© descartado para evitar mensagens de erro caso a pasta
/// atual n√£o seja um reposit√≥rio git.
fn get_git_branch() -> Option<String> {
    let output = Command::new("git")
        .arg("branch")
        .arg("--show-current")
        .stderr(Stdio::null()) // Silencia erros
        .output()
        .ok()?;

    if output.status.success() {
        let branch = String::from_utf8_lossy(&output.stdout).trim().to_string();
        if !branch.is_empty() {
            return Some(branch);
        }
    }
    None
}

/// Parser L√≥gico de `&&` com Contexto (N√≠vel 10).
///
/// Esta fun√ß√£o resolve o bug onde `echo "a && b"` era dividido incorretamente.
/// Ela percorre a string caractere por caractere mantendo um **Estado Interno**
/// para saber se est√° dentro de aspas ou n√£o.
///
/// # Como funciona (State Machine)
/// 
/// 1. **Normal:** Procura por `&&`. Se achar, corta.
/// 2. **Aspas Simples ('):** Ignora tudo at√© fechar a aspa.
/// 3. **Aspas Duplas ("):** Ignora `&&`, mas ainda processa outras coisas se necess√°rio.
fn split_logical_and(input: &str) -> Vec<String> {
    let mut parts = Vec::new();
    let mut current_part = String::new();
    
    // Flags de Estado
    let mut in_single_quote = false;
    let mut in_double_quote = false;
    
    let mut chars = input.chars().peekable();

    while let Some(c) = chars.next() {
        match c {
            '\'' => {
                // Inverte o estado de aspa simples se n√£o estiver em aspa dupla
                if !in_double_quote { in_single_quote = !in_single_quote; }
                current_part.push(c);
            }
            '"' => {
                // Inverte o estado de aspa dupla se n√£o estiver em aspa simples
                if !in_single_quote { in_double_quote = !in_double_quote; }
                current_part.push(c);
            }
            '&' => {
                // O PULO DO GATO:
                // S√≥ considera separador se N√ÉO estiver dentro de nenhuma aspa
                if !in_single_quote && !in_double_quote {
                    if let Some(&'&') = chars.peek() {
                        // Achou "&&" v√°lido e fora de aspas!
                        if !current_part.trim().is_empty() {
                            parts.push(current_part.clone());
                        }
                        current_part.clear(); // Limpa o buffer para o pr√≥ximo comando
                        chars.next(); // Consome o segundo '&'
                        continue;
                    }
                }
                current_part.push(c);
            }
            _ => current_part.push(c),
        }
    }
    // Adiciona o restinho que sobrou (o √∫ltimo comando da linha)
    if !current_part.trim().is_empty() {
        parts.push(current_part);
    }
    parts
}

/// Expans√£o de Alias em N√≠vel de String (N√≠vel 10.1).
///
/// Necess√°ria para aliases complexos que cont√™m `&&` ou `|`.
/// Em vez de expandir token a token (que acontece tarde demais),
/// expandimos a string bruta antes do parser l√≥gico rodar.
///
/// # Exemplo
/// * Alias: `update` -> `sudo apt update && sudo apt upgrade`
/// * Se n√£o fizermos isso aqui, o parser l√≥gico nunca veria o `&&` escondido.
fn expand_alias_string(input: &str, aliases: &HashMap<String, String>) -> String {
    let trimmed = input.trim_start();
    
    // Acha onde termina a primeira palavra (o nome do comando)
    let end_idx = trimmed.char_indices()
        .find(|(_, c)| c.is_whitespace())
        .map(|(i, _)| i)
        .unwrap_or(trimmed.len());
        
    let first_word = &trimmed[..end_idx];
    
    if let Some(val) = aliases.get(first_word) {
        // Se achou alias, troca a primeira palavra pelo valor completo
        let remainder = &trimmed[end_idx..];
        format!("{}{}", val, remainder)
    } else {
        input.to_string() // Se n√£o √© alias, devolve a string original
    }
}

/// Carrega a configura√ß√£o do usu√°rio a partir de um arquivo TOML.
///
/// # Estrat√©gia de Carregamento
/// 1. Busca pela vari√°vel de ambiente `$HOME`.
/// 2. Tenta abrir o arquivo `$HOME/.clios.toml`.
/// 3. Se o arquivo existir e for v√°lido, retorna a `CliosConfig` preenchida.
/// 4. Se o arquivo n√£o existir ou tiver erros de sintaxe, retorna `CliosConfig::default()`
///    e imprime um aviso no stderr (se for erro de sintaxe).
fn load_toml_config() -> CliosConfig {
    // 1. Constr√≥i o caminho ~/.clios.toml
    let config_path = env::var("HOME")
        .map(|p| Path::new(&p).join(".clios.toml"))
        .unwrap_or_else(|_| Path::new(".clios.toml").to_path_buf());

    // 2. Tenta ler e fazer o parse
    if config_path.exists() {
        if let Ok(mut file) = File::open(config_path) {
            let mut contents = String::new();
            if file.read_to_string(&mut contents).is_ok() {
                // Tenta converter o texto TOML em Struct Rust
                match toml::from_str::<CliosConfig>(&contents) {
                    Ok(cfg) => return cfg, // Sucesso!
                    Err(e) => {
                        eprintln!("\x1b[1;33m[AVISO CONFIG]\x1b[0m Erro no .clios.toml: {}", e);
                        eprintln!("--> Usando configura√ß√£o padr√£o.");
                    }
                }
            }
        }
    }

    // 3. Fallback para padr√£o
    CliosConfig::default()
}

/// Constr√≥i o prompt estilo Powerline "Costurando" os segmentos.
//// Cada segmento √© uma struct com texto, cor de fundo e cor de texto.
///# Exemplo de Segmentos
/// ```
/// vec![
///     PowerlineSegment { text: "user".to_string(), bg: "34".to_string(), fg: "15".to_string() },
///     PowerlineSegment { text: "/home/user".to_string(), bg: "28".to_string(), fg: "15".to_string() },
///     PowerlineSegment { text: "master".to_string(), bg: "124".to_string(), fg: "15".to_string() },
/// ]/// ```
fn build_powerline_prompt(segments: Vec<PowerlineSegment>) -> String {
    let mut prompt = String::new();

    // 1. Borda Redonda Inicial (O Truque)
    if let Some(first) = segments.first() {
        // Define a cor do TEXTO (38) igual ao FUNDO do primeiro bloco (first.bg)
        // \u{e0b6} √© o caractere de semic√≠rculo
        prompt.push_str(&format!("\x1b[38;5;{}m\u{e0b6}", first.bg)); 
    }
    
    for (i, segment) in segments.iter().enumerate() {
        // Desenha o bloco
        prompt.push_str(&format!("\x1b[48;5;{}m\x1b[38;5;{}m {} ", segment.bg, segment.fg, segment.text));

        // L√≥gica do Tri√¢ngulo de conex√£o
        let next_bg = if i + 1 < segments.len() {
            format!("\x1b[48;5;{}m", segments[i+1].bg)
        } else {
            "\x1b[0m".to_string() // Fundo transparente no final
        };

        let current_bg_as_fg = format!("\x1b[38;5;{}m", segment.bg);
        
        // Se for o √∫ltimo segmento, podemos usar um acabamento redondo tamb√©m (\u{e0b4})
        // ou manter o tri√¢ngulo vazio. Vamos manter o tri√¢ngulo por enquanto.
        prompt.push_str(&format!("{}{}\u{e0b0}", next_bg, current_bg_as_fg));
    }

    // Adiciona reset de cor e espa√ßo
    prompt.push_str("\x1b[0m");
    prompt
}

/// Gera os segmentos do Powerline com base no estado atual da Shell.
/// Cada segmento √© uma struct com texto, cor de fundo e cor de texto.
/// 1. √çcone do SO + Usu√°rio
/// 2. Diret√≥rio Atual
/// 3. Git Branch
/// 4. Contexto de Linguagem
/// 5. Rel√≥gio
fn get_powerline_segments(_shell: &CliosShell) -> Vec<PowerlineSegment> {
    let mut segments = Vec::new();

    // 1. √çcone do SO + Usu√°rio (Rosa - Cor 218)
    // Dica: Use "whoami" ou vari√°vel de ambiente. Aqui fixei para teste.
    let user = std::env::var("USER").unwrap_or("clios".to_string());
    segments.push(PowerlineSegment {
        text: format!("üêß {}", user), // Troque a ma√ß√£ por üêß se for Linux
        bg: "218".to_string(), // Rosa pastel
        fg: "0".to_string(),   // Preto
    });

    // 2. Diret√≥rio Atual (Laranja - Cor 215)
    if let Ok(path) = std::env::current_dir() {
        let path_str = path.display().to_string();
        // Truque para encurtar o home
        let home = std::env::var("HOME").unwrap_or_default();
        let short_path = path_str.replace(&home, "~"); // Troca /home/user por ~
        
        segments.push(PowerlineSegment {
            text: short_path,
            bg: "215".to_string(), // Laranja
            fg: "0".to_string(),
        });
    }

    // 3. Git Branch (Amarelo - Cor 229)
    if let Some(branch) = get_git_branch() {
        segments.push(PowerlineSegment {
            text: format!("ÓÇ† {}", branch), // √çcone de branch
            bg: "229".to_string(), // Amarelo claro
            fg: "0".to_string(),
        });
    }

    // 4. Contexto de Linguagem (Verde - Cor 150)
    // Reutilizando sua l√≥gica do N√≠vel 15, mas agora retornando segmento
    // 4. Contexto de Linguagem (Atualizado)
    // 4. Sistema Gen√©rico de Linguagens
    // Em vez de if/else infinitos, definimos regras:
    struct LangRule {
        file: &'static str,      // Arquivo gatilho
        icon: &'static str,      // √çcone
        color: String,           // Cor de fundo
        get_ver: fn() -> Option<String>, // Fun√ß√£o para ler vers√£o
    }

    // A lista de linguagens suportadas
    let languages = [
        LangRule { file: "Cargo.toml", icon: "", color: "150".to_string(), get_ver: get_rust_version },
        LangRule { file: "package.json", icon: "‚¨¢", color: "150".to_string(), get_ver: get_node_version },
        LangRule { file: "pyproject.toml", icon: "Óúº", color: "220".to_string(), get_ver: get_python_version }, // Amarelo/Dourado
        // Quer adicionar Go? √â s√≥ adicionar essa linha:
        // LangRule { file: "go.mod", icon: "üêπ", color: "75".to_string(), get_ver: || None }, 
    ];

    // O Loop que verifica tudo sozinho
    let mut found_lang = false;
    for lang in languages.iter() {
        if std::path::Path::new(lang.file).exists() {
            let version = (lang.get_ver)().unwrap_or_else(|| "".to_string());
            
            segments.push(PowerlineSegment {
                text: format!("{} {}", lang.icon, version).trim().to_string(),
                bg: lang.color.clone(),
                fg: "0".to_string(),
            });
            found_lang = true;
            break; // Achou uma, para (prioridade). Se quiser mostrar v√°rias, remove o break.
        }
    }

    // Se n√£o achou pyproject.toml mas tem arquivos python soltos
    if !found_lang && (std::path::Path::new("requirements.txt").exists() || std::path::Path::new("main.py").exists()) {
         segments.push(PowerlineSegment {
            text: "üêç Py".to_string(),
            bg: "220".to_string(),
            fg: "0".to_string(),
        });
    }

    // 5. Rel√≥gio (Azul - Cor 117)
    let time = Local::now().format("%H:%M").to_string();
    segments.push(PowerlineSegment {
        text: format!("üïë {}", time),
        bg: "117".to_string(),
        fg: "0".to_string(),
    });

    segments
}

/// Tenta ler a vers√£o do arquivo Cargo.toml
fn get_rust_version() -> Option<String> {
    let content = fs::read_to_string("Cargo.toml").ok()?; // L√™ o arquivo ou desiste
    let cargo: CargoToml = toml::from_str(&content).ok()?; // Faz o parse ou desiste
    Some(format!("v{}", cargo.package.version))
}

/// Tenta ler a vers√£o do arquivo package.json
fn get_node_version() -> Option<String> {
    let content = fs::read_to_string("package.json").ok()?;
    let pkg: PackageJson = serde_json::from_str(&content).ok()?;
    Some(format!("v{}", pkg.version))
}

/// L√™ vers√£o do Python (pyproject.toml)
fn get_python_version() -> Option<String> {
    let content = fs::read_to_string("pyproject.toml").ok()?;
    let py: PyProjectToml = toml::from_str(&content).ok()?;

    // Tenta achar no padr√£o oficial [project]
    if let Some(proj) = py.project {
        if let Some(v) = proj.version {
            return Some(format!("v{}", v));
        }
    }
    
    // Se n√£o achar, tenta no Poetry [tool.poetry]
    if let Some(tool) = py.tool {
        if let Some(poetry) = tool.poetry {
             if let Some(v) = poetry.version {
                return Some(format!("v{}", v));
            }
        }
    }

    None
}