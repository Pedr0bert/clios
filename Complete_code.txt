================================================================================
                    CLIOS SHELL - CÓDIGO FONTE COMPLETO
                              Versão 0.7.0
================================================================================
Projeto: Shell híbrida Rust + Rhai para Linux/Unix
Repositório: https://github.com/pedbelivros/clios
================================================================================

ESTRUTURA DO PROJETO:
- src/main.rs         - Ponto de entrada e CLI
- src/shell.rs        - Core da shell e loop principal
- src/builtins.rs     - Comandos internos (cd, alias, export, etc.)
- src/pipeline.rs     - Execução de pipelines e redirecionamentos
- src/expansion.rs    - Expansões ($VAR, ~, globs, subshells, aliases)
- src/jobs.rs         - Job control (fg, bg, processos background)
- src/prompt.rs       - Prompt powerline personalizado
- src/config.rs       - Carregamento de configurações
- src/completion.rs   - Autocomplete e syntax highlighting
- src/rhai_integration.rs - Integração com scripting Rhai
- src/tests.rs        - Testes unitários

================================================================================


// ============================================================================
// FILE: src/main.rs
// ============================================================================
//! # Clios Shell (Command Line Interface & Operating System Shell)
//!
//! Bem-vindo à documentação oficial da **Clios**, uma shell híbrida desenvolvida em Rust.
//!
//! ## Funcionalidades Principais:
//! * **Interatividade:** Prompt rico com histórico e autocomplete (via `rustyline`).
//! * **Scripting:** Suporte nativo à linguagem Rhai para scripts complexos.
//! * **Job Control:** Gerenciamento de processos Unix (bg, fg, signals) via `nix`.
//! * **Parsing:** Suporte a pipes `|`, redirecionamento `>` e lógica `&&`.
//!
//! ##  Como Usar
//!
//! ```bash
//! # Modo Interativo
//! clios
//!
//! # Executar Script
//! clios script.rhai
//!
//! # Comando Único
//! clios -c "echo Hello World"
//! ```

// --- MODULE DECLARATIONS ---
mod builtins;
mod completion;
mod config;
mod expansion;
mod jobs;
mod pipeline;
mod prompt;
mod rhai_integration;
mod shell;

#[cfg(test)]
mod tests;

// --- IMPORTS ---
use completion::CliosHelper;
use config::{get_color_ansi, load_toml_config};
use prompt::{build_powerline_prompt, get_git_branch, get_powerline_segments};
use rhai_integration::run_rhai_script;
use shell::CliosShell;

use rustyline::error::ReadlineError;
use rustyline::history::DefaultHistory;
use rustyline::Editor;
use std::env;
use std::fs::File;
use std::io::{BufRead, BufReader};
use std::path::Path;

// -----------------------------------------------------------------------------
// MAIN FUNCTION
// -----------------------------------------------------------------------------

fn main() -> rustyline::Result<()> {
    // 1. Load configuration
    let loaded_config = load_toml_config();

    // 2. Initialize the Shell
    let mut shell = CliosShell::new(loaded_config);

    // Load auto-plugins from ~/.clios_plugins
    shell.load_auto_plugins();

    // Load user config from ~/.cliosrc
    shell.load_config();

    // --- COMMAND LINE ARGUMENTS ---
    let args: Vec<String> = env::args().collect();

    if args.len() > 1 {
        // CASE A: Flag -c (Single command)
        if args[1] == "-c" {
            if args.len() > 2 {
                let command = &args[2];
                let _ = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
                    shell.process_input_line(command);
                }));
            } else {
                eprintln!("Erro: -c requer um comando entre aspas");
                std::process::exit(1);
            }
            return Ok(());
        }

        // CASE B: Rhai Script (.rhai)
        if args[1].ends_with(".rhai") {
            println!("--- Executando Script Rhai ---");
            if let Err(e) = run_rhai_script(&args[1]) {
                eprintln!("Erro no script Rhai: {}", e);
                std::process::exit(1);
            }
            return Ok(());
        }

        // CASE C: Shell Script
        let script_path = Path::new(&args[1]);
        if let Ok(file) = File::open(script_path) {
            let reader = BufReader::new(file);
            for line in reader.lines() {
                if let Ok(l) = line
                    && !l.trim().is_empty() && !l.starts_with('#') {
                        let _ = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
                            shell.process_input_line(&l);
                        }));
                    }
            }
            return Ok(());
        } else {
            eprintln!("Erro: Arquivo não encontrado '{}'", args[1]);
            std::process::exit(1);
        }
    }

    // --- INTERACTIVE MODE ---

    // Extract history configuration
    let (hist_file, max_entries) = if let Some(h) = &shell.config.history {
        (
            h.file.as_deref().unwrap_or(".clios_history"),
            h.max_entries.unwrap_or(1000),
        )
    } else {
        (".clios_history", 1000)
    };

    // Configure Rustyline
    let config = rustyline::Config::builder()
        .auto_add_history(false)
        .max_history_size(max_entries)
        .unwrap()
        .build();

    // Get syntax highlighting colors
    let (valid_str, invalid_str) = if let Some(syntax) = &shell.config.syntax {
        (
            syntax.valid_cmd.as_deref().unwrap_or("green"),
            syntax.invalid_cmd.as_deref().unwrap_or("red"),
        )
    } else {
        ("green", "red")
    };

    // Create the helper
    let h = CliosHelper::new(get_color_ansi(valid_str), get_color_ansi(invalid_str));

    // Initialize the Editor
    let mut rl: Editor<CliosHelper, DefaultHistory> = Editor::with_config(config)?;
    rl.set_helper(Some(h));

    // History path
    let history_path = env::var("HOME")
        .map(|p| Path::new(&p).join(hist_file))
        .unwrap_or_else(|_| Path::new(hist_file).to_path_buf());

    // Load history
    if rl.load_history(&history_path).is_err() {
        println!("Bem-vindo ao Clios Shell v1.0 (Final Release) ");
        println!("Digite 'create' para iniciar um projeto ou 'rhai' para scripts.");
    }

    // Theme control
    let mut current_theme = shell
        .config
        .theme
        .clone()
        .unwrap_or_else(|| "powerline".to_string());

    // --- MAIN LOOP (REPL) ---
    loop {
        let final_prompt = if current_theme == "powerline" {
            // Powerline mode
            let segments = get_powerline_segments(&shell.config);
            let prompt_bar = build_powerline_prompt(segments);
            format!("{} \x1b[1;32m❯\x1b[0m ", prompt_bar)
        } else {
            // Classic mode
            build_classic_prompt(&shell)
        };

        // Inject prompt into Rustyline
        if let Some(helper) = rl.helper_mut() {
            helper.colored_prompt = final_prompt.clone();
        }

        match rl.readline(&final_prompt) {
            Ok(line) => {
                let input = line.trim();
                if input.is_empty() {
                    continue;
                }

                // Theme switching commands
                if input == "theme classic" {
                    current_theme = "classic".to_string();
                    continue;
                }
                if input == "theme powerline" {
                    current_theme = "powerline".to_string();
                    continue;
                }

                // Save to history
                let _ = rl.add_history_entry(input);
                let _ = rl.append_history(&history_path);

                // Execute
                let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
                    shell.process_input_line(input);
                }));
                if result.is_err() {
                    eprintln!("\n(!) Panic recuperado.");
                }
            }
            Err(ReadlineError::Interrupted) => {
                println!("CTRL-C");
                continue;
            }
            Err(ReadlineError::Eof) => {
                break;
            }
            Err(_) => {
                break;
            }
        }
    }

    // Save history on exit
    rl.save_history(&history_path)?;
    Ok(())
}

// -----------------------------------------------------------------------------
// HELPER FUNCTIONS
// -----------------------------------------------------------------------------

/// Builds the classic (customizable) prompt.
fn build_classic_prompt(shell: &CliosShell) -> String {
    let current_dir = env::current_dir().unwrap_or_default();
    let dir_display = current_dir.display();

    let (symbol, default_color, path_color_cfg, symbol_color_cfg, show_git) =
        if let Some(p) = &shell.config.prompt {
            (
                p.symbol.as_deref().unwrap_or(">"),
                p.color.as_deref().unwrap_or("blue"),
                p.path_color.as_deref(),
                p.symbol_color.as_deref(),
                p.show_git.unwrap_or(true),
            )
        } else {
            (">", "blue", None, None, true)
        };

    let path_ansi = get_color_ansi(path_color_cfg.unwrap_or(default_color));
    let arrow_ansi = get_color_ansi(symbol_color_cfg.unwrap_or(default_color));

    let git_color = if show_git {
        if let Some(branch) = get_git_branch() {
            format!(" (\x1b[1;35m{}\x1b[0m)", branch)
        } else {
            String::new()
        }
    } else {
        String::new()
    };

    let arrow_colored = if shell.last_exit_code == 0 {
        format!("{}{}\x1b[0m ", arrow_ansi, symbol)
    } else {
        format!("\x1b[1;31m[{}]>\x1b[0m ", shell.last_exit_code)
    };

    format!(
        "{}{}:{}{}\x1b[0m{}",
        path_ansi, "clios", dir_display, git_color, arrow_colored
    )
}


// ============================================================================
// FILE: src/shell.rs
// ============================================================================
//! # Shell Module
//!
//! Contains the main CliosShell struct and core shell logic.
//!
//! ## Responsabilidades
//! - Manter o estado global da sessão
//! - Processar linhas de entrada
//! - Gerenciar aliases e plugins
//! - Coordenar expansões e execução de comandos

use crate::builtins::{handle_builtin, BuiltinResult};
use crate::config::CliosConfig;
use crate::expansion::{
    expand_alias_string, expand_globs, expand_subshells, expand_tilde, expand_variables_with_state,
    split_logical_operators, LogicalOp,
};
use crate::jobs::{execute_job_control, JobList, new_job_list};
use crate::pipeline::execute_pipeline;
use crate::rhai_integration::{create_rhai_engine, try_execute_plugin_function};

use rhai::{Engine, Scope, AST};
use std::collections::HashMap;
use std::env;
use std::fs::{self, File};
use std::io::{BufRead, BufReader};
use std::path::{Path, PathBuf};

// -----------------------------------------------------------------------------
// HELPER FUNCTIONS
// -----------------------------------------------------------------------------

/// Divide uma string por pipes (|) respeitando aspas.
/// 
/// Esta função percorre a string caractere por caractere e só divide por |
/// quando não está dentro de aspas simples ou duplas.
fn split_pipes_respecting_quotes(input: &str) -> Vec<String> {
    let mut parts = Vec::new();
    let mut current = String::new();
    let mut in_single_quote = false;
    let mut in_double_quote = false;
    let chars = input.chars().peekable();

    for c in chars {
        match c {
            '\'' if !in_double_quote => {
                in_single_quote = !in_single_quote;
                current.push(c);
            }
            '"' if !in_single_quote => {
                in_double_quote = !in_double_quote;
                current.push(c);
            }
            '|' if !in_single_quote && !in_double_quote => {
                parts.push(current.clone());
                current.clear();
            }
            _ => current.push(c),
        }
    }

    // Adiciona a última parte
    if !current.is_empty() {
        parts.push(current);
    }

    // Se não encontrou nenhum pipe ou se parts está vazio, retorna input
    if parts.is_empty() {
        vec![input.to_string()]
    } else {
        parts
    }
}

// -----------------------------------------------------------------------------
// CLIOS SHELL STRUCT
// -----------------------------------------------------------------------------

/// # CliosShell (O Coração Lógico)
///
/// Esta estrutura mantém o **Estado Global** da sessão da shell.
/// Diferente do Helper (que cuida da tela), aqui ficam os dados que precisam
/// persistir entre um comando e outro.
pub struct CliosShell {
    /// Mapa de apelidos (Aliases). Ex: "update" -> "sudo apt update".
    pub aliases: HashMap<String, String>,

    /// O Motor (Engine) da linguagem de script Rhai.
    pub rhai_engine: Engine,

    /// O Escopo (Scope) da linguagem Rhai.
    pub rhai_scope: Scope<'static>,

    /// O Código de Saída (Exit Code) do último comando executado.
    pub last_exit_code: i32,

    /// Armazena o caminho do diretório anterior.
    pub previous_dir: Option<PathBuf>,

    /// Configurações carregadas do arquivo TOML.
    pub config: CliosConfig,

    /// AST do script de inicialização (se houver).
    pub plugin_ast: Option<AST>,
    
    /// Lista de jobs em background
    pub jobs: JobList,
}

impl CliosShell {
    /// Construtor: Inicializa a Shell e configura o motor de Script (Rhai).
    pub fn new(config: CliosConfig) -> Self {
        let engine = create_rhai_engine();

        Self {
            aliases: HashMap::new(),
            rhai_engine: engine,
            rhai_scope: Scope::new(),
            plugin_ast: None,
            last_exit_code: 0,
            previous_dir: None,
            config,
            jobs: new_job_list(),
        }
    }

    /// NÍVEL 12: Carregador de Plugins (Compilação Única)
    /// Retorna Ok(()) em sucesso ou Err(mensagem) em falha
    pub fn load_plugin(&mut self, path: &str) -> Result<(), String> {
        // Verificar se o arquivo existe
        if !std::path::Path::new(path).exists() {
            return Err(format!("\x1b[1;31m[ERRO PLUGIN]\x1b[0m Arquivo não encontrado: {}", path));
        }

        match self.rhai_engine.compile_file(path.into()) {
            Ok(new_ast) => {
                if let Some(ref mut existing_ast) = self.plugin_ast {
                    *existing_ast += new_ast;
                } else {
                    self.plugin_ast = Some(new_ast);
                }
                Ok(())
            }
            Err(e) => {
                Err(format!("\x1b[1;31m[ERRO PLUGIN]\x1b[0m Falha ao compilar '{}'\n  Detalhes: {}", path, e))
            }
        }
    }

    /// NÍVEL 17: Auto-Loader de Plugins
    pub fn load_auto_plugins(&mut self) {
        let home = env::var("HOME").unwrap_or_else(|_| ".".to_string());
        let plugins_dir = Path::new(&home).join(".clios_plugins");

        if let Ok(entries) = fs::read_dir(plugins_dir) {
            for entry in entries.flatten() {
                let path = entry.path();

                if path.is_file() && path.extension().and_then(|s| s.to_str()) == Some("rhai")
                    && let Some(path_str) = path.to_str() {
                        if let Err(e) = self.load_plugin(path_str) {
                            eprintln!("{}", e);
                        }
                    }
            }
        }
    }

    /// Lê o arquivo de configuração `~/.cliosrc` e executa linha por linha.
    pub fn load_config(&mut self) {
        if let Ok(home) = env::var("HOME") {
            let config_path = Path::new(&home).join(".cliosrc");
            if config_path.exists()
                && let Ok(file) = File::open(config_path) {
                    let reader = BufReader::new(file);

                    for (i, line) in reader.lines().enumerate() {
                        if let Ok(l) = line {
                            let l = l.trim();

                            if !l.is_empty() && !l.starts_with('#') {
                                if shlex::split(l).is_none() {
                                    eprintln!(
                                        "\x1b[1;31m[ERRO CONFIG]\x1b[0m .cliosrc Linha {}: Aspas não fechadas.",
                                        i + 1
                                    );
                                    eprintln!("--> Conteúdo: {}", l);
                                    continue;
                                }

                                self.process_input_line(l);
                            }
                        }
                    }
                }
        }
    }

    /// O Cérebro da Execução: Processa uma linha de entrada bruta.
    /// Suporta operadores && (AND) e || (OR) com curto-circuito.
    pub fn process_input_line(&mut self, input: &str) {
        let input_expanded = expand_subshells(input);

        let logical_parts = split_logical_operators(&input_expanded);

        for part in logical_parts {
            let expanded_part = expand_alias_string(&part.command, &self.aliases);

            // Se o alias expandido contém operadores lógicos, processa recursivamente
            if expanded_part != part.command && (expanded_part.contains("&&") || expanded_part.contains("||")) {
                self.process_input_line(&expanded_part);

                // Aplica curto-circuito baseado no operador
                match part.next_op {
                    Some(LogicalOp::And) if self.last_exit_code != 0 => break,
                    Some(LogicalOp::Or) if self.last_exit_code == 0 => break,
                    _ => continue,
                }
            }

            let exit_code = self.execute_single_command_block(&expanded_part);
            self.last_exit_code = exit_code;

            // Curto-circuito baseado no operador
            match part.next_op {
                Some(LogicalOp::And) if exit_code != 0 => break,  // && falha: para
                Some(LogicalOp::Or) if exit_code == 0 => break,   // || sucesso: para
                _ => {}  // Continua para o próximo comando
            }
        }
    }

    /// Executa um bloco de comando único (sem &&, mas pode ter Pipes |).
    fn execute_single_command_block(&mut self, input: &str) -> i32 {
        // Validação: entrada vazia ou só espaços
        if input.trim().is_empty() {
            return 0;
        }

        let commands_raw = split_pipes_respecting_quotes(input);

        if commands_raw.len() == 1 {
            let raw_line = commands_raw[0].trim();

            let background = raw_line.ends_with('&');
            let clean_line = if background {
                raw_line[..raw_line.len() - 1].trim()
            } else {
                raw_line
            };

            let mut tokens = match shlex::split(clean_line) {
                Some(t) => t,
                None => {
                    eprintln!(
                        "\x1b[1;31m[ERRO SINTAXE]\x1b[0m Falha ao processar: '{}'",
                        clean_line
                    );
                    return 1;
                }
            };

            // Tratamento Rhai
            if tokens.first().map(|s| s.as_str()) == Some("rhai")
                && let Some(idx) = clean_line.find("rhai") {
                    let code_part = clean_line[idx + 4..].trim();
                    tokens = vec!["rhai".to_string(), code_part.to_string()];
                }

            // Expansões finais
            if tokens.first().map(|s| s.as_str()) != Some("rhai") {
                tokens = expand_variables_with_state(tokens, self.last_exit_code, std::process::id());
                tokens = expand_tilde(tokens);
                tokens = expand_globs(tokens);
            }

            if tokens.is_empty() {
                return 0;
            }

            let cmd_name = tokens[0].clone();
            let args = tokens[1..].to_vec();

            // 1. Tenta Plugin
            if let Some(ast) = &self.plugin_ast
                && try_execute_plugin_function(
                    &self.rhai_engine,
                    &mut self.rhai_scope,
                    ast,
                    &cmd_name,
                    args.clone(),
                ) {
                    return 0;
                }

            // 2. Tenta Builtin
            // Obtém arquivo de histórico da config
            let history_file = self.config.history
                .as_ref()
                .and_then(|h| h.file.as_deref())
                .unwrap_or(".clios_history");
            
            let jobs_ref = self.jobs.clone();
            let result = handle_builtin(
                &tokens,
                &mut self.aliases,
                &mut self.previous_dir,
                &mut self.rhai_engine,
                &mut self.rhai_scope,
                &mut self.plugin_ast,
                |engine, ast, path| -> Result<(), String> {
                    match engine.compile_file(path.into()) {
                        Ok(new_ast) => {
                            if let Some(existing_ast) = ast {
                                *existing_ast += new_ast;
                            } else {
                                *ast = Some(new_ast);
                            }
                            Ok(())
                        }
                        Err(e) => Err(format!("\x1b[1;31m[ERRO PLUGIN]\x1b[0m Falha ao compilar '{}': {}", path, e)),
                    }
                },
                history_file,
                &jobs_ref,
            );

            match result {
                BuiltinResult::Handled => return 0,
                BuiltinResult::Exit => std::process::exit(0),
                BuiltinResult::NotBuiltin => {}
            }

            // 3. Executa como programa externo
            if background {
                execute_job_control(tokens, true);
                0
            } else {
                execute_pipeline(vec![tokens])
            }
        } else {
            // Pipeline
            let mut parsed_commands = Vec::new();

            for raw_cmd in commands_raw {
                let expanded_cmd = expand_alias_string(&raw_cmd, &self.aliases);
                let trimmed = expanded_cmd.trim();
                
                if trimmed.is_empty() {
                    continue;
                }

                // Tenta shlex primeiro, se falhar usa split simples por espaços
                let tokens = match shlex::split(trimmed) {
                    Some(t) if !t.is_empty() => t,
                    _ => {
                        // Fallback: split simples por espaços em branco
                        trimmed
                            .split_whitespace()
                            .map(|s| s.to_string())
                            .collect()
                    }
                };

                if tokens.is_empty() {
                    continue;
                }

                let tokens = expand_variables_with_state(tokens, self.last_exit_code, std::process::id());
                let tokens = expand_tilde(tokens);
                let tokens = expand_globs(tokens);

                parsed_commands.push(tokens);
            }
            
            if parsed_commands.is_empty() {
                return 0;
            }
            
            execute_pipeline(parsed_commands)
        }
    }
}


// ============================================================================
// FILE: src/builtins.rs
// ============================================================================
//! # Builtins Module
//!
//! Contains all built-in shell commands that are executed internally
//! rather than spawning external processes.
//!
//! ## Comandos Suportados
//! - `cd` - Navegar entre diretórios
//! - `pwd` - Exibir diretório atual
//! - `alias` - Gerenciar aliases
//! - `export` - Definir variáveis de ambiente
//! - `history` - Exibir histórico de comandos
//! - `source/load` - Carregar plugins Rhai
//! - `plugins` - Listar plugins carregados
//! - `rhai` - Executar código Rhai
//! - `fg` - Trazer processo para foreground
//! - `exit` - Sair da shell

use nix::sys::signal::{self, Signal};
use nix::sys::wait::{self, WaitPidFlag};
use nix::unistd::{self, Pid};
use rhai::{Engine, Scope, AST};
use std::collections::HashMap;
use std::env;
use std::fs::File;
use std::io::{BufRead, BufReader};
use std::path::PathBuf;

use crate::jobs::{JobList, list_jobs};

// -----------------------------------------------------------------------------
// BUILTIN EXECUTION
// -----------------------------------------------------------------------------

/// Resultado da execução de um builtin.
pub enum BuiltinResult {
    /// O comando foi tratado como builtin.
    Handled,
    /// O comando não era um builtin.
    NotBuiltin,
    /// O shell deve sair.
    Exit,
}

/// Executa comandos internos da Shell (Builtins).
/// Retorna o resultado da execução.
#[allow(clippy::too_many_arguments)]
pub fn handle_builtin(
    tokens: &[String],
    aliases: &mut HashMap<String, String>,
    previous_dir: &mut Option<PathBuf>,
    rhai_engine: &mut Engine,
    rhai_scope: &mut Scope,
    plugin_ast: &mut Option<AST>,
    load_plugin_fn: impl Fn(&mut Engine, &mut Option<AST>, &str) -> Result<(), String>,
    history_file: &str,
    jobs_list: &JobList,
) -> BuiltinResult {
    if tokens.is_empty() {
        return BuiltinResult::NotBuiltin;
    }

    match tokens[0].as_str() {
        "cd" => {
            handle_cd(tokens, previous_dir);
            BuiltinResult::Handled
        }
        "history" => {
            handle_history(history_file);
            BuiltinResult::Handled
        }
        "source" | "load" => {
            if let Some(path) = tokens.get(1) {
                if let Err(e) = load_plugin_fn(rhai_engine, plugin_ast, path) {
                    eprintln!("{}", e);
                }
            } else {
                println!("Uso: source <arquivo.rhai>");
            }
            BuiltinResult::Handled
        }
        "plugins" => {
            handle_plugins(plugin_ast);
            BuiltinResult::Handled
        }
        "pwd" => {
            if let Ok(path) = env::current_dir() {
                println!("{}", path.display());
            }
            BuiltinResult::Handled
        }
        "exit" => BuiltinResult::Exit,
        "alias" => {
            handle_alias(tokens, aliases);
            BuiltinResult::Handled
        }
        "rhai" => {
            handle_rhai_command(tokens, rhai_engine, rhai_scope, plugin_ast);
            BuiltinResult::Handled
        }
        "fg" => {
            handle_fg(tokens);
            BuiltinResult::Handled
        }
        "jobs" => {
            list_jobs(jobs_list);
            BuiltinResult::Handled
        }
        "export" => {
            handle_export(tokens);
            BuiltinResult::Handled
        }
        "unalias" => {
            handle_unalias(tokens, aliases);
            BuiltinResult::Handled
        }
        "unset" => {
            handle_unset(tokens);
            BuiltinResult::Handled
        }
        "type" => {
            handle_type(tokens, aliases);
            BuiltinResult::Handled
        }
        "help" => {
            handle_help();
            BuiltinResult::Handled
        }
        "version" => {
            println!("Clios Shell v0.7.0");
            println!("Desenvolvido em Rust");
            BuiltinResult::Handled
        }
        _ => BuiltinResult::NotBuiltin,
    }
}

// -----------------------------------------------------------------------------
// INDIVIDUAL BUILTIN HANDLERS
// -----------------------------------------------------------------------------

/// Handles the `cd` command.
fn handle_cd(tokens: &[String], previous_dir: &mut Option<PathBuf>) {
    let target = if let Some(arg) = tokens.get(1) {
        if arg == "-" {
            if let Some(prev) = previous_dir {
                println!("{}", prev.display());
                Some(prev.clone())
            } else {
                println!("Erro: Nenhuma pasta anterior definida");
                None
            }
        } else {
            Some(PathBuf::from(arg))
        }
    } else {
        env::var("HOME").ok().map(PathBuf::from)
    };

    if let Some(new_dir) = target {
        if let Ok(current) = env::current_dir() {
            *previous_dir = Some(current);
        }

        if let Err(e) = env::set_current_dir(&new_dir) {
            eprintln!("cd: {}", e);
        }
    }
}

/// Handles the `history` command.
fn handle_history(history_file: &str) {
    let home = std::env::var("HOME").unwrap_or_else(|_| ".".to_string());
    let history_path = std::path::Path::new(&home).join(history_file);
    
    if let Ok(file) = File::open(&history_path) {
        let reader = BufReader::new(file);
        for (i, line) in reader.lines().enumerate() {
            if let Ok(l) = line {
                // Ignora linhas de metadata do rustyline (começam com #)
                if !l.starts_with('#') {
                    println!("{:5}  {}", i + 1, l);
                }
            }
        }
    } else {
        println!("Histórico vazio ou arquivo não encontrado: {}", history_path.display());
    }
}

/// Handles the `plugins` command.
fn handle_plugins(plugin_ast: &Option<AST>) {
    if let Some(ast) = plugin_ast {
        println!("Comandos de Plugins Ativos:");
        println!("----------------------------");

        for func in ast.iter_functions() {
            if !func.name.starts_with('_') {
                println!("  ➜ {} ({} args)", func.name, func.params.len());
            }
        }
        println!("----------------------------");
    } else {
        println!("Nenhum plugin carregado na memória.");
    }
}

/// Handles the `alias` command.
fn handle_alias(tokens: &[String], aliases: &mut HashMap<String, String>) {
    if tokens.len() < 2 {
        for (name, val) in aliases.iter() {
            println!("{}='{}'", name, val);
        }
    } else {
        let arg = tokens[1..].join(" ");
        if let Some((name, value)) = arg.split_once('=') {
            aliases.insert(name.to_string(), value.to_string());
        } else {
            println!("Erro: Use alias nome=valor");
        }
    }
}

/// Handles the `rhai` command.
fn handle_rhai_command(tokens: &[String], rhai_engine: &mut Engine, rhai_scope: &mut Scope, plugin_ast: &Option<AST>) {
    let code = tokens.get(1).map(|s| s.as_str()).unwrap_or("").trim();

    if code.is_empty() {
        // Modo REPL
        run_rhai_repl(rhai_engine, rhai_scope, plugin_ast);
    } else {
        // Execução One-Shot - combina com funções do plugin se disponível
        let result = if let Some(ast) = plugin_ast {
            // Compila o código do usuário e combina com o AST do plugin
            match rhai_engine.compile(code) {
                Ok(user_ast) => {
                    let combined = ast.clone().merge(&user_ast);
                    rhai_engine.eval_ast_with_scope::<rhai::Dynamic>(rhai_scope, &combined)
                }
                Err(e) => Err(e.into())
            }
        } else {
            rhai_engine.eval_with_scope::<rhai::Dynamic>(rhai_scope, code)
        };
        match result {
            Ok(valor) => {
                if valor.type_name() != "()" {
                    println!("=> {}", valor);
                }
            }
            Err(e) => println!("Erro Rhai: {}", e),
        }
    }
}

/// Handles the `fg` command.
fn handle_fg(tokens: &[String]) {
    if let Some(pid_str) = tokens.get(1) {
        if let Ok(pid_int) = pid_str.parse::<i32>() {
            let pid = Pid::from_raw(pid_int);

            let _ = signal::kill(pid, Signal::SIGCONT);
            let _ = unistd::tcsetpgrp(std::io::stdin(), pid);
            let _ = wait::waitpid(pid, Some(WaitPidFlag::WUNTRACED));

            let shell_pgid = unistd::getpid();
            let _ = unistd::tcsetpgrp(std::io::stdin(), shell_pgid);
        }
    } else {
        println!("Uso: fg <PID>");
    }
}

/// Handles the `export` command.
fn handle_export(tokens: &[String]) {
    if tokens.len() < 2 {
        println!("Uso: export VAR=VALOR");
    } else {
        let arg = tokens[1..].join("");
        if let Some((key, value)) = arg.split_once('=') {
            unsafe {
                std::env::set_var(key, value);
            }
        } else {
            println!("Erro: Use formato VAR=VALOR");
        }
    }
}

// -----------------------------------------------------------------------------
// RHAI REPL
// -----------------------------------------------------------------------------

/// Executa o modo interativo dedicado ao Rhai (REPL).
fn run_rhai_repl(rhai_engine: &mut Engine, rhai_scope: &mut Scope, plugin_ast: &Option<AST>) {
    println!("Entrando no modo Rhai (Digite 'exit' para sair)");

    let mut rl = rustyline::DefaultEditor::new().unwrap_or_else(|_| panic!("Falha ao iniciar REPL"));

    let mut input_buffer = String::new();
    let mut open_braces = 0;

    loop {
        let prompt = if input_buffer.is_empty() {
            "rhai> "
        } else {
            "... "
        };

        match rl.readline(prompt) {
            Ok(line) => {
                let trimmed = line.trim();

                if trimmed == "exit" && input_buffer.is_empty() {
                    break;
                }

                open_braces += trimmed.matches('{').count();
                let closed = trimmed.matches('}').count();

                if closed > open_braces {
                    open_braces = 0;
                } else {
                    open_braces -= closed;
                }

                input_buffer.push_str(&line);
                input_buffer.push('\n');

                if open_braces == 0 {
                    // Combina com funções do plugin se disponível
                    let result = if let Some(ast) = plugin_ast {
                        match rhai_engine.compile(&input_buffer) {
                            Ok(user_ast) => {
                                let combined = ast.clone().merge(&user_ast);
                                rhai_engine.eval_ast_with_scope::<rhai::Dynamic>(rhai_scope, &combined)
                            }
                            Err(e) => Err(e.into())
                        }
                    } else {
                        rhai_engine.eval_with_scope::<rhai::Dynamic>(rhai_scope, &input_buffer)
                    };

                    match result {
                        Ok(val) => {
                            if val.type_name() != "()" {
                                println!("=> {}", val);
                            }
                        }
                        Err(e) => println!("Erro: {}", e),
                    }

                    input_buffer.clear();
                }
            }
            Err(_) => break,
        }
    }
}

// -----------------------------------------------------------------------------
// NOVOS BUILTINS
// -----------------------------------------------------------------------------

/// Handles the `unalias` command - remove um alias.
fn handle_unalias(tokens: &[String], aliases: &mut HashMap<String, String>) {
    if tokens.len() < 2 {
        eprintln!("Uso: unalias <nome>");
        return;
    }

    let name = &tokens[1];
    if aliases.remove(name).is_some() {
        println!("Alias '{}' removido.", name);
    } else {
        eprintln!("Alias '{}' não encontrado.", name);
    }
}

/// Handles the `unset` command - remove uma variável de ambiente.
fn handle_unset(tokens: &[String]) {
    if tokens.len() < 2 {
        eprintln!("Uso: unset <VARIAVEL>");
        return;
    }

    for var in &tokens[1..] {
        unsafe {
            env::remove_var(var);
        }
    }
}

/// Handles the `type` command - mostra o tipo de um comando.
fn handle_type(tokens: &[String], aliases: &HashMap<String, String>) {
    if tokens.len() < 2 {
        eprintln!("Uso: type <comando>");
        return;
    }

    let cmd = &tokens[1];

    // Verificar se é um alias
    if let Some(val) = aliases.get(cmd) {
        println!("{} is aliased to '{}'", cmd, val);
        return;
    }

    // Verificar se é um builtin
    let builtins = [
        "cd", "pwd", "alias", "unalias", "export", "unset", "history",
        "source", "load", "plugins", "rhai", "fg", "exit", "type", "help", "version"
    ];
    if builtins.contains(&cmd.as_str()) {
        println!("{} is a shell builtin", cmd);
        return;
    }

    // Verificar se é um executável no PATH
    if let Ok(path_var) = env::var("PATH") {
        for path in path_var.split(':') {
            let full_path = std::path::Path::new(path).join(cmd);
            if full_path.exists() && full_path.is_file() {
                println!("{} is {}", cmd, full_path.display());
                return;
            }
        }
    }

    eprintln!("{}: not found", cmd);
}

/// Handles the `help` command - exibe ajuda.
fn handle_help() {
    println!("\x1b[1;36m╔══════════════════════════════════════════════════════════════╗\x1b[0m");
    println!("\x1b[1;36m║\x1b[0m           \x1b[1;33mClios Shell v1.0.0\x1b[0m - Comandos Internos           \x1b[1;36m║\x1b[0m");
    println!("\x1b[1;36m╠══════════════════════════════════════════════════════════════╣\x1b[0m");
    println!("\x1b[1;36m║\x1b[0m \x1b[1;32mNavegação:\x1b[0m                                                   \x1b[1;36m║\x1b[0m");
    println!("\x1b[1;36m║\x1b[0m   cd [dir]        Mudar diretório (cd - para anterior)       \x1b[1;36m║\x1b[0m");
    println!("\x1b[1;36m║\x1b[0m   pwd             Exibir diretório atual                     \x1b[1;36m║\x1b[0m");
    println!("\x1b[1;36m║\x1b[0m                                                              \x1b[1;36m║\x1b[0m");
    println!("\x1b[1;36m║\x1b[0m \x1b[1;32mAliases:\x1b[0m                                                     \x1b[1;36m║\x1b[0m");
    println!("\x1b[1;36m║\x1b[0m   alias           Listar todos os aliases                    \x1b[1;36m║\x1b[0m");
    println!("\x1b[1;36m║\x1b[0m   alias x='cmd'   Criar alias                                \x1b[1;36m║\x1b[0m");
    println!("\x1b[1;36m║\x1b[0m   unalias <nome>  Remover alias                              \x1b[1;36m║\x1b[0m");
    println!("\x1b[1;36m║\x1b[0m                                                              \x1b[1;36m║\x1b[0m");
    println!("\x1b[1;36m║\x1b[0m \x1b[1;32mVariáveis:\x1b[0m                                                   \x1b[1;36m║\x1b[0m");
    println!("\x1b[1;36m║\x1b[0m   export VAR=val  Definir variável de ambiente               \x1b[1;36m║\x1b[0m");
    println!("\x1b[1;36m║\x1b[0m   unset VAR       Remover variável de ambiente               \x1b[1;36m║\x1b[0m");
    println!("\x1b[1;36m║\x1b[0m                                                              \x1b[1;36m║\x1b[0m");
    println!("\x1b[1;36m║\x1b[0m \x1b[1;32mPlugins (Rhai):\x1b[0m                                              \x1b[1;36m║\x1b[0m");
    println!("\x1b[1;36m║\x1b[0m   source <file>   Carregar plugin Rhai                       \x1b[1;36m║\x1b[0m");
    println!("\x1b[1;36m║\x1b[0m   plugins         Listar plugins carregados                  \x1b[1;36m║\x1b[0m");
    println!("\x1b[1;36m║\x1b[0m   rhai <código>   Executar código Rhai inline                \x1b[1;36m║\x1b[0m");
    println!("\x1b[1;36m║\x1b[0m   rhai            Entrar no modo REPL Rhai                   \x1b[1;36m║\x1b[0m");
    println!("\x1b[1;36m║\x1b[0m                                                              \x1b[1;36m║\x1b[0m");
    println!("\x1b[1;36m║\x1b[0m \x1b[1;32mOutros:\x1b[0m                                                      \x1b[1;36m║\x1b[0m");
    println!("\x1b[1;36m║\x1b[0m   history         Exibir histórico de comandos               \x1b[1;36m║\x1b[0m");
    println!("\x1b[1;36m║\x1b[0m   type <cmd>      Mostrar tipo do comando                    \x1b[1;36m║\x1b[0m");
    println!("\x1b[1;36m║\x1b[0m   fg <PID>        Trazer processo para foreground            \x1b[1;36m║\x1b[0m");
    println!("\x1b[1;36m║\x1b[0m   version         Exibir versão da shell                     \x1b[1;36m║\x1b[0m");
    println!("\x1b[1;36m║\x1b[0m   help            Exibir esta ajuda                          \x1b[1;36m║\x1b[0m");
    println!("\x1b[1;36m║\x1b[0m   exit            Sair da shell                              \x1b[1;36m║\x1b[0m");
    println!("\x1b[1;36m║\x1b[0m                                                              \x1b[1;36m║\x1b[0m");
    println!("\x1b[1;36m║\x1b[0m \x1b[1;32mOperadores:\x1b[0m                                                  \x1b[1;36m║\x1b[0m");
    println!("\x1b[1;36m║\x1b[0m   cmd1 | cmd2     Pipeline (conectar stdout -> stdin)        \x1b[1;36m║\x1b[0m");
    println!("\x1b[1;36m║\x1b[0m   cmd1 && cmd2    Executar cmd2 se cmd1 sucesso              \x1b[1;36m║\x1b[0m");
    println!("\x1b[1;36m║\x1b[0m   cmd > file      Redirecionar stdout para arquivo           \x1b[1;36m║\x1b[0m");
    println!("\x1b[1;36m║\x1b[0m   cmd >> file     Append stdout ao arquivo                   \x1b[1;36m║\x1b[0m");
    println!("\x1b[1;36m║\x1b[0m   cmd 2> file     Redirecionar stderr para arquivo           \x1b[1;36m║\x1b[0m");
    println!("\x1b[1;36m║\x1b[0m   cmd &           Executar em background                     \x1b[1;36m║\x1b[0m");
    println!("\x1b[1;36m╚══════════════════════════════════════════════════════════════╝\x1b[0m");
}


// ============================================================================
// FILE: src/pipeline.rs
// ============================================================================
//! # Pipeline Module
//!
//! Handles pipeline execution, I/O redirection, and process management.
//!
//! ## Funcionalidades
//! - Execução de pipelines de comandos (`cmd1 | cmd2 | cmd3`)
//! - Redirecionamento de I/O (`>`, `>>`, `2>`, `2>>`)
//! - Gerenciamento de processos filhos

use std::fs::{File, OpenOptions};
use std::process::{Child, Command, Stdio};

// -----------------------------------------------------------------------------
// CONSTANTES
// -----------------------------------------------------------------------------

/// Código de saída padrão POSIX para "comando não encontrado"
const EXIT_COMMAND_NOT_FOUND: i32 = 127;

/// Código de saída para erros genéricos
const EXIT_ERROR: i32 = 1;

// -----------------------------------------------------------------------------
// I/O REDIRECTION PARSING
// -----------------------------------------------------------------------------

/// Analisa e processa operadores de redirecionamento de I/O (Nível 9).
///
/// Esta função percorre a lista de tokens procurando por operadores especiais
/// de redirecionamento. Quando encontra, ela abre o arquivo correspondente
/// e o remove da lista de argumentos do comando.
///
/// # Operadores Suportados
/// * `<`   : Redireciona **STDIN** (Lê do arquivo).
/// * `>`   : Redireciona **STDOUT** (Sobrescreve o arquivo).
/// * `>>`  : Redireciona **STDOUT** (Adiciona ao final do arquivo - Append).
/// * `2>`  : Redireciona **STDERR** (Sobrescreve o arquivo).
/// * `2>>` : Redireciona **STDERR** (Adiciona ao final do arquivo - Append).
///
/// # Retorno
/// Retorna uma tupla `(Vec<String>, Option<File>, Option<File>, Option<File>)`:
/// 1. **Argumentos Limpos:** O comando sem os símbolos de redirecionamento.
/// 2. **Arquivo Entrada:** O arquivo aberto para onde vem o stdin (se houver).
/// 3. **Arquivo Saída:** O arquivo aberto para onde vai o stdout (se houver).
/// 4. **Arquivo Erro:** O arquivo aberto para onde vai o stderr (se houver).
pub fn parse_redirection(tokens: &[String]) -> (Vec<String>, Option<File>, Option<File>, Option<File>) {
    let mut clean = Vec::new();
    let mut stdin_file = None;
    let mut stdout_file = None;
    let mut stderr_file = None;

    let mut iter = tokens.iter().peekable();

    while let Some(t) = iter.next() {
        match t.as_str() {
            // Entrada Padrão (Read)
            "<" => {
                if let Some(f) = iter.next() {
                    match File::open(f) {
                        Ok(o) => stdin_file = Some(o),
                        Err(e) => {
                            eprintln!("\x1b[1;31m[ERRO REDIRECIONAMENTO]\x1b[0m Falha ao abrir '{}': {}", f, e);
                        }
                    }
                } else {
                    eprintln!("\x1b[1;31m[ERRO SINTAXE]\x1b[0m Operador '<' requer um arquivo");
                }
            }
            // Saída Padrão (Overwrite)
            ">" => {
                if let Some(f) = iter.next() {
                    match OpenOptions::new()
                        .write(true)
                        .create(true)
                        .truncate(true)
                        .open(f)
                    {
                        Ok(o) => stdout_file = Some(o),
                        Err(e) => {
                            eprintln!("\x1b[1;31m[ERRO REDIRECIONAMENTO]\x1b[0m Falha ao abrir '{}': {}", f, e);
                        }
                    }
                } else {
                    eprintln!("\x1b[1;31m[ERRO SINTAXE]\x1b[0m Operador '>' requer um arquivo");
                }
            }
            // Saída Padrão (Append)
            ">>" => {
                if let Some(f) = iter.next() {
                    match OpenOptions::new()
                        
                        .create(true)
                        .append(true)
                        .open(f)
                    {
                        Ok(o) => stdout_file = Some(o),
                        Err(e) => {
                            eprintln!("\x1b[1;31m[ERRO REDIRECIONAMENTO]\x1b[0m Falha ao abrir '{}': {}", f, e);
                        }
                    }
                } else {
                    eprintln!("\x1b[1;31m[ERRO SINTAXE]\x1b[0m Operador '>>' requer um arquivo");
                }
            }
            // Saída de Erro (Overwrite)
            "2>" => {
                if let Some(f) = iter.next() {
                    match OpenOptions::new()
                        .write(true)
                        .create(true)
                        .truncate(true)
                        .open(f)
                    {
                        Ok(o) => stderr_file = Some(o),
                        Err(e) => {
                            eprintln!("\x1b[1;31m[ERRO REDIRECIONAMENTO]\x1b[0m Falha ao abrir '{}': {}", f, e);
                        }
                    }
                } else {
                    eprintln!("\x1b[1;31m[ERRO SINTAXE]\x1b[0m Operador '2>' requer um arquivo");
                }
            }
            // Saída de Erro (Append)
            "2>>" => {
                if let Some(f) = iter.next() {
                    match OpenOptions::new()
                        
                        .create(true)
                        .append(true)
                        .open(f)
                    {
                        Ok(o) => stderr_file = Some(o),
                        Err(e) => {
                            eprintln!("\x1b[1;31m[ERRO REDIRECIONAMENTO]\x1b[0m Falha ao abrir '{}': {}", f, e);
                        }
                    }
                } else {
                    eprintln!("\x1b[1;31m[ERRO SINTAXE]\x1b[0m Operador '2>>' requer um arquivo");
                }
            }
            // Token normal
            _ => clean.push(t.clone()),
        }
    }
    (clean, stdin_file, stdout_file, stderr_file)
}

// -----------------------------------------------------------------------------
// PIPELINE EXECUTION
// -----------------------------------------------------------------------------

/// Executa uma "Pipeline" de comandos (ex: `ls | grep txt | wc -l`).
///
/// Esta é a função que realmente faz os programas rodarem. Ela gerencia:
/// 1. **Pipes:** Conecta a saída de um comando na entrada do próximo.
/// 2. **Redirecionamento:** Conecta arquivos (`>`, `2>`) se necessário.
/// 3. **Exit Codes:** Captura se o comando deu certo ou errado.
///
/// # Como funciona (The Daisy Chain)
/// Em um pipe `A | B | C`:
/// * **A**: Stdin = Teclado, Stdout = Pipe(A->B)
/// * **B**: Stdin = Pipe(A->B), Stdout = Pipe(B->C)
/// * **C**: Stdin = Pipe(B->C), Stdout = Tela
pub fn execute_pipeline(commands: Vec<Vec<String>>) -> i32 {
    // Validação: pipeline vazio
    if commands.is_empty() {
        return 0;
    }

    // Validação: todos os comandos estão vazios
    if commands.iter().all(|cmd| cmd.is_empty()) {
        eprintln!("\x1b[1;33m[AVISO]\x1b[0m Pipeline vazio detectado");
        return 0;
    }

    let mut prev_cmd: Option<Child> = None;
    let mut final_exit_code = 0;

    for (i, tokens) in commands.iter().enumerate() {
        if tokens.is_empty() {
            eprintln!("\x1b[1;33m[AVISO]\x1b[0m Comando vazio no pipeline (posição {})", i + 1);
            continue;
        }

        // 1. Separa o comando dos redirecionamentos de arquivo
        let (mut args, infile, outfile, errfile) = parse_redirection(tokens);

        if args.is_empty() {
            continue;
        }

        let cmd = args.remove(0);

        // 2. Configuração do STDIN
        let stdin = if let Some(f) = infile {
            // Redirecionamento de entrada tem prioridade
            Stdio::from(f)
        } else if let Some(mut child) = prev_cmd {
            Stdio::from(child.stdout.take().unwrap())
        } else {
            Stdio::inherit()
        };

        // 3. Configuração do STDOUT
        let stdout = if let Some(f) = outfile {
            Stdio::from(f)
        } else if i < commands.len() - 1 {
            Stdio::piped()
        } else {
            Stdio::inherit()
        };

        // 4. Configuração do STDERR
        let stderr = if let Some(f) = errfile {
            Stdio::from(f)
        } else {
            Stdio::inherit()
        };

        // 5. Executa (Spawn)
        match Command::new(&cmd)
            .args(&args)
            .stdin(stdin)
            .stdout(stdout)
            .stderr(stderr)
            .spawn()
        {
            Ok(child) => prev_cmd = Some(child),
            Err(e) => {
                // Mensagem de erro mais descritiva baseada no tipo de erro
                let error_msg = if e.kind() == std::io::ErrorKind::NotFound {
                    format!("comando não encontrado: '{}'", cmd)
                } else if e.kind() == std::io::ErrorKind::PermissionDenied {
                    format!("permissão negada: '{}'", cmd)
                } else {
                    format!("erro ao executar '{}': {}", cmd, e)
                };
                eprintln!("\x1b[1;31m[ERRO]\x1b[0m {}", error_msg);
                return EXIT_COMMAND_NOT_FOUND;
            }
        }
    }

    // 6. Espera Final
    if let Some(mut final_child) = prev_cmd
        && let Ok(status) = final_child.wait() {
            final_exit_code = status.code().unwrap_or(EXIT_ERROR);
        }

    final_exit_code
}


// ============================================================================
// FILE: src/expansion.rs
// ============================================================================
//! # Expansion Module
//!
//! Handles all types of shell expansions:
//! - Variable expansion ($HOME, $USER, ${VAR})
//! - Tilde expansion (~)
//! - Glob expansion (*.rs, src/*)
//! - Subshell expansion ($(command))
//! - Alias expansion

use glob::glob;
use std::collections::HashMap;
use std::env;
use std::process::Command;

// -----------------------------------------------------------------------------
// VARIABLE EXPANSION
// -----------------------------------------------------------------------------

/// Expansão Recursiva de Variáveis de Ambiente (Nível 10).
///
/// Varre cada token procurando por padrões `$VAR` ou `${VAR}` e substitui
/// pelo valor real do sistema operacional. Funciona inclusive no meio de strings.
///
/// Também suporta variáveis especiais:
/// - `$?` - Código de saída do último comando
/// - `$$` - PID da shell atual
///
/// # Exemplo
/// * Entrada: `echo Backup_$USER.tar.gz`
/// * Saída: `echo Backup_pedro.tar.gz`
#[allow(dead_code)]
pub fn expand_variables(tokens: Vec<String>) -> Vec<String> {
    expand_variables_with_state(tokens, 0, std::process::id())
}

/// Versão com estado para suportar $? e $$
pub fn expand_variables_with_state(tokens: Vec<String>, last_exit_code: i32, shell_pid: u32) -> Vec<String> {
    tokens
        .into_iter()
        .map(|token| {
            // Otimização: Se não tem '$', retorna o token original imediatamente
            if !token.contains('$') {
                return token;
            }

            let mut output = String::new();
            let mut chars = token.chars().peekable();

            while let Some(c) = chars.next() {
                if c == '$' {
                    // Variáveis especiais de um único caractere
                    if let Some(&next_c) = chars.peek() {
                        match next_c {
                            '?' => {
                                chars.next(); // Consome '?'
                                output.push_str(&last_exit_code.to_string());
                                continue;
                            }
                            '$' => {
                                chars.next(); // Consome '$'
                                output.push_str(&shell_pid.to_string());
                                continue;
                            }
                            _ => {}
                        }
                    }
                    
                    // Início de uma variável normal
                    let mut var_name = String::new();
                    let mut is_bracketed = false;

                    if let Some(&'{') = chars.peek() {
                        is_bracketed = true;
                        chars.next(); // Consome '{'
                    }

                    // Lê o nome da variável (Letras, Números ou Underline)
                    while let Some(&next_c) = chars.peek() {
                        if next_c.is_alphanumeric() || next_c == '_' {
                            var_name.push(next_c);
                            chars.next();
                        } else {
                            if is_bracketed && next_c == '}' {
                                chars.next(); // Consome '}' final
                            }
                            break;
                        }
                    }

                    // Se extraiu um nome válido, busca no Sistema Operacional
                    if !var_name.is_empty() {
                        if let Ok(val) = env::var(&var_name) {
                            output.push_str(&val);
                        }
                    } else {
                        output.push('$');
                    }
                } else {
                    output.push(c);
                }
            }
            output
        })
        .collect()
}

// -----------------------------------------------------------------------------
// TILDE EXPANSION
// -----------------------------------------------------------------------------

/// Expansão do Til (`~`).
///
/// No Linux, `~` é um atalho para a pasta HOME do usuário.
/// Esta função substitui tokens que começam com `~` pelo caminho absoluto.
///
/// # Exemplos
/// * `cd ~` -> `cd /home/pedro`
/// * `ls ~/Downloads` -> `ls /home/pedro/Downloads`
pub fn expand_tilde(tokens: Vec<String>) -> Vec<String> {
    let home = env::var("HOME").unwrap_or_else(|_| "/".to_string());

    tokens
        .into_iter()
        .map(|t| {
            if t == "~" {
                home.clone()
            } else if t.starts_with("~/") {
                format!("{}{}", home, &t[1..])
            } else {
                t
            }
        })
        .collect()
}

// -----------------------------------------------------------------------------
// GLOB EXPANSION
// -----------------------------------------------------------------------------

/// Expansão de "Globs" (Curingas de Arquivo).
///
/// Utiliza a crate `glob` para transformar padrões como `*.rs` ou `src/*`
/// em uma lista de arquivos reais do disco.
///
/// # Comportamento
/// * Se encontrar arquivos: Substitui o token pela lista de arquivos.
/// * Se NÃO encontrar: Mantém o token original.
pub fn expand_globs(tokens: Vec<String>) -> Vec<String> {
    let mut expanded_tokens = Vec::new();
    for token in tokens {
        if token.contains('*') || token.contains('?') {
            match glob(&token) {
                Ok(paths) => {
                    let mut found = false;
                    for p in paths.flatten() {
                        if let Some(s) = p.to_str() {
                            expanded_tokens.push(s.to_string());
                            found = true;
                        }
                    }
                    if !found {
                        expanded_tokens.push(token);
                    }
                }
                Err(_) => {
                    expanded_tokens.push(token);
                }
            }
        } else {
            expanded_tokens.push(token);
        }
    }
    expanded_tokens
}

// -----------------------------------------------------------------------------
// SUBSHELL EXPANSION
// -----------------------------------------------------------------------------

/// Expansão de "Command Substitution" ou Subshell `$()`.
///
/// Detecta padrões `$(comando)` dentro de uma string, executa o comando ocultamente,
/// captura a saída (STDOUT) e substitui o padrão pelo resultado.
///
/// # Exemplo
/// * Entrada: `echo Hoje é $(date)`
/// * Execução: Roda `date`, captura "Sáb Dez 14..."
/// * Saída: `echo Hoje é Sáb Dez 14...`
pub fn expand_subshells(input: &str) -> String {
    let mut output = String::new();
    let mut chars = input.chars().peekable();

    while let Some(c) = chars.next() {
        if c == '$' && chars.peek() == Some(&'(') {
            chars.next(); // Consome o '(' inicial

            let mut nested = 0;
            let mut inner = String::new();
            let mut closed = false;

            for inner_c in chars.by_ref() {
                if inner_c == '(' {
                    nested += 1;
                    inner.push(inner_c);
                } else if inner_c == ')' {
                    if nested > 0 {
                        nested -= 1;
                        inner.push(inner_c);
                    } else {
                        closed = true;
                        break;
                    }
                } else {
                    inner.push(inner_c);
                }
            }

            if closed {
                if inner.trim().is_empty() {
                    eprintln!("\x1b[1;33m[AVISO]\x1b[0m Subshell vazio: $()");
                } else {
                    let result = execute_and_capture(&inner);
                    output.push_str(&result);
                }
            } else {
                eprintln!("\x1b[1;31m[ERRO SINTAXE]\x1b[0m Subshell não fechado: $({}", inner);
                output.push_str("$(");
                output.push_str(&inner);
            }
            continue;
        }
        output.push(c);
    }
    output
}

/// Executa um comando e captura sua saída (STDOUT) como string.
fn execute_and_capture(cmd_line: &str) -> String {
    let tokens = match shlex::split(cmd_line) {
        Some(t) => t,
        None => {
            eprintln!("\x1b[1;31m[ERRO]\x1b[0m Falha ao processar subshell: '{}'", cmd_line);
            return String::new();
        }
    };
    if tokens.is_empty() {
        return String::new();
    }

    let prog = &tokens[0];
    let args = &tokens[1..];

    // Truque para recursão Rhai
    if prog == "rhai"
        && let Ok(myself) = env::current_exe() {
            let output = Command::new(myself).arg("-c").arg(cmd_line).output();

            return match output {
                Ok(out) => {
                    if !out.status.success() {
                        eprintln!("\x1b[1;33m[AVISO]\x1b[0m Comando rhai no subshell falhou");
                    }
                    String::from_utf8_lossy(&out.stdout).trim().to_string()
                },
                Err(e) => {
                    eprintln!("\x1b[1;31m[ERRO]\x1b[0m Falha ao executar subshell rhai: {}", e);
                    String::new()
                }
            };
        }

    // Execução normal
    let output = Command::new(prog).args(args).output();

    match output {
        Ok(out) => {
            if !out.status.success() {
                eprintln!("\x1b[1;33m[AVISO]\x1b[0m Comando '{}' no subshell retornou erro", prog);
            }
            String::from_utf8_lossy(&out.stdout).trim().to_string()
        },
        Err(e) => {
            eprintln!("\x1b[1;31m[ERRO]\x1b[0m Comando '{}' não encontrado no subshell: {}", prog, e);
            String::new()
        }
    }
}

// -----------------------------------------------------------------------------
// ALIAS EXPANSION
// -----------------------------------------------------------------------------

/// Expansão de Alias em Nível de String (Nível 10.1).
///
/// Necessária para aliases complexos que contêm `&&` ou `|`.
/// Em vez de expandir token a token (que acontece tarde demais),
/// expandimos a string bruta antes do parser lógico rodar.
///
/// Inclui proteção contra aliases recursivos infinitos.
pub fn expand_alias_string(input: &str, aliases: &HashMap<String, String>) -> String {
    expand_alias_string_with_depth(input, aliases, 0)
}

fn expand_alias_string_with_depth(input: &str, aliases: &HashMap<String, String>, depth: usize) -> String {
    // Prevenir recursão infinita (máximo 10 níveis)
    if depth > 10 {
        eprintln!("\x1b[1;33m[AVISO]\x1b[0m Alias recursivo detectado, interrompendo expansão");
        return input.to_string();
    }

    let trimmed = input.trim_start();

    // Acha onde termina a primeira palavra (o nome do comando)
    let end_idx = trimmed
        .char_indices()
        .find(|(_, c)| c.is_whitespace())
        .map(|(i, _)| i)
        .unwrap_or(trimmed.len());

    let first_word = &trimmed[..end_idx];

    if let Some(val) = aliases.get(first_word) {
        let remainder = &trimmed[end_idx..];
        let expanded = format!("{}{}", val, remainder);
        
        // Verificar se o alias expandido começa com o mesmo comando (recursão direta)
        let expanded_first_word = expanded.split_whitespace()
            .next()
            .unwrap_or("");
        
        if expanded_first_word == first_word {
            //eprintln!("\x1b[1;33m[AVISO]\x1b[0m Alias '{}' se refere a si mesmo, usando comando original", first_word);
            return input.to_string();
        }
        
        // Tentar expandir recursivamente
        expand_alias_string_with_depth(&expanded, aliases, depth + 1)
    } else {
        input.to_string()
    }
}

// -----------------------------------------------------------------------------
// LOGICAL OPERATORS PARSER
// -----------------------------------------------------------------------------

/// Tipo de operador lógico encontrado
#[derive(Debug, Clone, PartialEq)]
pub enum LogicalOp {
    And,  // &&
    Or,   // ||
}

/// Uma parte do comando com o operador que a segue
#[derive(Debug, Clone)]
pub struct LogicalPart {
    pub command: String,
    pub next_op: Option<LogicalOp>,
}

/// Parser Lógico de `&&` e `||` com Contexto (Nível 10).
///
/// Esta função resolve o bug onde `echo "a && b"` era dividido incorretamente.
/// Ela percorre a string caractere por caractere mantendo um **Estado Interno**
/// para saber se está dentro de aspas ou não.
///
/// Retorna uma lista de partes com seus operadores, permitindo curto-circuito.
pub fn split_logical_operators(input: &str) -> Vec<LogicalPart> {
    let mut parts = Vec::new();
    let mut current_part = String::new();

    let mut in_single_quote = false;
    let mut in_double_quote = false;

    let mut chars = input.chars().peekable();

    while let Some(c) = chars.next() {
        match c {
            '\'' => {
                if !in_double_quote {
                    in_single_quote = !in_single_quote;
                }
                current_part.push(c);
            }
            '"' => {
                if !in_single_quote {
                    in_double_quote = !in_double_quote;
                }
                current_part.push(c);
            }
            '&' => {
                if !in_single_quote && !in_double_quote
                    && let Some(&'&') = chars.peek() {
                        if !current_part.trim().is_empty() {
                            parts.push(LogicalPart {
                                command: current_part.clone(),
                                next_op: Some(LogicalOp::And),
                            });
                        }
                        current_part.clear();
                        chars.next(); // Consome o segundo '&'
                        continue;
                    }
                current_part.push(c);
            }
            '|' => {
                if !in_single_quote && !in_double_quote
                    && let Some(&'|') = chars.peek() {
                        if !current_part.trim().is_empty() {
                            parts.push(LogicalPart {
                                command: current_part.clone(),
                                next_op: Some(LogicalOp::Or),
                            });
                        }
                        current_part.clear();
                        chars.next(); // Consome o segundo '|'
                        continue;
                    }
                current_part.push(c);
            }
            _ => current_part.push(c),
        }
    }

    if !current_part.trim().is_empty() {
        parts.push(LogicalPart {
            command: current_part,
            next_op: None,
        });
    }
    parts
}

/// Mantém compatibilidade com código existente - retorna apenas Vec<String>
#[allow(dead_code)]
pub fn split_logical_and(input: &str) -> Vec<String> {
    split_logical_operators(input)
        .into_iter()
        .map(|p| p.command)
        .collect()
}


// ============================================================================
// FILE: src/jobs.rs
// ============================================================================
//! # Jobs Module
//!
//! Handles job control with low-level Unix process management.
//! Uses `nix` crate for fork/exec and signal handling.

use nix::sys::signal::{self, SigHandler, Signal};
use nix::sys::wait::{self, WaitPidFlag, WaitStatus};
use nix::unistd;
use std::collections::HashMap;
use std::process::Command;
use std::sync::{Arc, Mutex};
use std::time::Instant;

// -----------------------------------------------------------------------------
// JOB TRACKING
// -----------------------------------------------------------------------------

/// Representa um job em background
#[derive(Debug, Clone)]
pub struct BackgroundJob {
    /// PID do processo
    pub pid: i32,
    /// Comando que está sendo executado
    pub command: String,
    /// Hora de início
    pub started: Instant,
    /// Status atual
    pub status: JobStatus,
}

/// Status de um job
#[derive(Debug, Clone, PartialEq)]
pub enum JobStatus {
    Running,
    Stopped,
    Done,
}

/// Lista global de jobs em background
pub type JobList = Arc<Mutex<HashMap<i32, BackgroundJob>>>;

/// Cria uma nova lista de jobs vazia
pub fn new_job_list() -> JobList {
    Arc::new(Mutex::new(HashMap::new()))
}

/// Adiciona um job à lista
#[allow(dead_code)]
pub fn add_job(jobs: &JobList, pid: i32, command: String) {
    if let Ok(mut list) = jobs.lock() {
        list.insert(pid, BackgroundJob {
            pid,
            command,
            started: Instant::now(),
            status: JobStatus::Running,
        });
    }
}

/// Remove um job da lista
#[allow(dead_code)]
pub fn remove_job(jobs: &JobList, pid: i32) {
    if let Ok(mut list) = jobs.lock() {
        list.remove(&pid);
    }
}

/// Atualiza o status de jobs (verifica se terminaram)
pub fn update_jobs(jobs: &JobList) {
    if let Ok(mut list) = jobs.lock() {
        let pids: Vec<i32> = list.keys().cloned().collect();
        
        for pid in pids {
            match wait::waitpid(unistd::Pid::from_raw(pid), Some(WaitPidFlag::WNOHANG)) {
                Ok(WaitStatus::Exited(_, _)) | Ok(WaitStatus::Signaled(_, _, _)) => {
                    if let Some(job) = list.get_mut(&pid) {
                        job.status = JobStatus::Done;
                    }
                }
                Ok(WaitStatus::Stopped(_, _)) => {
                    if let Some(job) = list.get_mut(&pid) {
                        job.status = JobStatus::Stopped;
                    }
                }
                _ => {}
            }
        }
        
        // Remove jobs concluídos
        list.retain(|_, job| job.status != JobStatus::Done);
    }
}

/// Lista todos os jobs ativos
pub fn list_jobs(jobs: &JobList) {
    update_jobs(jobs);
    
    if let Ok(list) = jobs.lock() {
        if list.is_empty() {
            println!("Nenhum job em background");
            return;
        }
        
        println!("Jobs em background:");
        println!("{:>5}  {:>10}  {}", "PID", "Status", "Comando");
        println!("{:-<40}", "");
        
        for job in list.values() {
            let status_str = match job.status {
                JobStatus::Running => "Running",
                JobStatus::Stopped => "Stopped",
                JobStatus::Done => "Done",
            };
            let elapsed = job.started.elapsed().as_secs();
            println!("{:>5}  {:>10}  {} ({}s)", job.pid, status_str, job.command, elapsed);
        }
    }
}

// -----------------------------------------------------------------------------
// JOB CONTROL EXECUTION
// -----------------------------------------------------------------------------

/// Execução de baixo nível com controle total de Processos (Job Control - Nível 5).
///
/// Diferente do `execute_pipeline` (que usa a std lib), esta função usa `nix` para
/// chamar `fork` e `exec` manualmente. Isso é necessário para manipular
/// **Process Groups** e definir quem é o "dono" do terminal.
///
/// # A Dança do Terminal (Terminal Handoff)
/// Para que o `Ctrl+C` vá para o processo certo, precisamos transferir a posse
/// do terminal (STDIN) da Shell para o Processo Filho.
///
/// 1. **Shell:** Ignora `SIGTTOU` (para não ser suspensa ao mexer no terminal).
/// 2. **Fork:** Cria uma cópia do processo.
/// 3. **Pai & Filho:** Ambos tentam setar o `setpgid` (para evitar race conditions).
/// 4. **Pai:** Dá o terminal pro filho (`tcsetpgrp`) e espera (`waitpid`).
/// 5. **Pai:** Quando o filho morre/para, pega o terminal de volta.
pub fn execute_job_control(tokens: Vec<String>, background: bool) {
    // Segurança: Ignorar SIGTTOU na shell
    unsafe { signal::signal(Signal::SIGTTOU, SigHandler::SigIgn) }.unwrap();

    match unsafe { unistd::fork() } {
        Ok(unistd::ForkResult::Parent { child, .. }) => {
            // --- CÓDIGO DO PAI (SHELL) ---
            let pgid = child;

            let _ = unistd::setpgid(child, pgid);

            if !background {
                let _ = unistd::tcsetpgrp(std::io::stdin(), pgid);

                match wait::waitpid(child, Some(WaitPidFlag::WUNTRACED)) {
                    Ok(WaitStatus::Stopped(_, _sig)) => {
                        println!("\n[Job {}] Pausado (Ctrl+Z)", child);
                    }
                    Ok(WaitStatus::Signaled(_, sig, _)) => {
                        println!("\n[Job {}] Morto pelo sinal: {:?}", child, sig);
                    }
                    _ => {}
                }

                let shell_pgid = unistd::getpid();
                let _ = unistd::tcsetpgrp(std::io::stdin(), shell_pgid);
            } else {
                println!("[Background Job {}]", child);
            }
        }
        Ok(unistd::ForkResult::Child) => {
            // --- CÓDIGO DO FILHO (COMANDO) ---
            let pid = unistd::getpid();
            let _ = unistd::setpgid(pid, pid);

            if !background {
                let _ = unistd::tcsetpgrp(std::io::stdin(), pid);
            }

            unsafe { signal::signal(Signal::SIGTTOU, SigHandler::SigDfl) }.unwrap();
            unsafe { signal::signal(Signal::SIGINT, SigHandler::SigDfl) }.unwrap();

            use std::os::unix::process::CommandExt;

            let err = Command::new(&tokens[0]).args(&tokens[1..]).exec();

            eprintln!("Erro ao executar '{}': {}", tokens[0], err);
            std::process::exit(1);
        }
        Err(_) => println!("Fork falhou - Sistema sem recursos"),
    }
}


// ============================================================================
// FILE: src/prompt.rs
// ============================================================================
//! # Prompt Module
//!
//! Handles prompt building, including the Powerline theme and Git branch detection.

use crate::config::{CargoToml, CliosConfig, PackageJson, PyProjectToml};
use chrono::Local;
use std::fs;
use std::process::{Command, Stdio};

// -----------------------------------------------------------------------------
// POWERLINE SEGMENT
// -----------------------------------------------------------------------------

/// Estrutura para representar um "bloco" colorido do prompt
pub struct PowerlineSegment {
    pub text: String,
    pub bg: String, // Código de cor ANSI do fundo (ex: "218")
    pub fg: String, // Código de cor ANSI do texto (ex: "0" para preto)
}

// -----------------------------------------------------------------------------
// GIT DETECTION
// -----------------------------------------------------------------------------

/// Detecta a Branch do Git para o Prompt (Nível 7).
///
/// Executa `git branch --show-current` em um processo separado.
/// O `stderr` é descartado para evitar mensagens de erro caso a pasta
/// atual não seja um repositório git.
pub fn get_git_branch() -> Option<String> {
    let output = Command::new("git")
        .arg("branch")
        .arg("--show-current")
        .stderr(Stdio::null()) // Silencia erros
        .output()
        .ok()?;

    if output.status.success() {
        let branch = String::from_utf8_lossy(&output.stdout).trim().to_string();
        if !branch.is_empty() {
            return Some(branch);
        }
    }
    None
}

// -----------------------------------------------------------------------------
// VERSION READING
// -----------------------------------------------------------------------------

/// Tenta ler a versão do arquivo Cargo.toml
pub fn get_rust_version() -> Option<String> {
    let content = fs::read_to_string("Cargo.toml").ok()?;
    let cargo: CargoToml = toml::from_str(&content).ok()?;
    Some(format!("v{}", cargo.package.version))
}

/// Tenta ler a versão do arquivo package.json
pub fn get_node_version() -> Option<String> {
    let content = fs::read_to_string("package.json").ok()?;
    let pkg: PackageJson = serde_json::from_str(&content).ok()?;
    Some(format!("v{}", pkg.version))
}

/// Lê versão do Python (pyproject.toml)
pub fn get_python_version() -> Option<String> {
    let content = fs::read_to_string("pyproject.toml").ok()?;
    let py: PyProjectToml = toml::from_str(&content).ok()?;

    // Tenta achar no padrão oficial [project]
    if let Some(proj) = py.project
        && let Some(v) = proj.version {
            return Some(format!("v{}", v));
        }

    // Se não achar, tenta no Poetry [tool.poetry]
    if let Some(tool) = py.tool
        && let Some(poetry) = tool.poetry
            && let Some(v) = poetry.version {
                return Some(format!("v{}", v));
            }

    None
}

// -----------------------------------------------------------------------------
// POWERLINE PROMPT BUILDING
// -----------------------------------------------------------------------------

/// Constrói o prompt estilo Powerline "Costurando" os segmentos.
/// Cada segmento é uma struct com texto, cor de fundo e cor de texto.
pub fn build_powerline_prompt(segments: Vec<PowerlineSegment>) -> String {
    let mut prompt = String::new();

    // 1. Borda Redonda Inicial (O Truque)
    if let Some(first) = segments.first() {
        // Define a cor do TEXTO (38) igual ao FUNDO do primeiro bloco (first.bg)
        // \u{e0b6} é o caractere de semicírculo
        prompt.push_str(&format!("\x1b[38;5;{}m\u{e0b6}", first.bg));
    }

    for (i, segment) in segments.iter().enumerate() {
        // Desenha o bloco
        prompt.push_str(&format!(
            "\x1b[48;5;{}m\x1b[38;5;{}m {} ",
            segment.bg, segment.fg, segment.text
        ));

        // Lógica do Triângulo de conexão
        let next_bg = if i + 1 < segments.len() {
            format!("\x1b[48;5;{}m", segments[i + 1].bg)
        } else {
            "\x1b[0m".to_string() // Fundo transparente no final
        };

        let current_bg_as_fg = format!("\x1b[38;5;{}m", segment.bg);

        prompt.push_str(&format!("{}{}\u{e0b0}", next_bg, current_bg_as_fg));
    }

    // Adiciona reset de cor e espaço
    prompt.push_str("\x1b[0m");
    prompt
}

/// Gera os segmentos do Powerline com base no estado atual da Shell.
/// Cada segmento é uma struct com texto, cor de fundo e cor de texto.
/// 1. Ícone do SO + Usuário
/// 2. Diretório Atual
/// 3. Git Branch
/// 4. Contexto de Linguagem
/// 5. Relógio
pub fn get_powerline_segments(_config: &CliosConfig) -> Vec<PowerlineSegment> {
    let mut segments = Vec::new();

    // 1. Ícone do SO + Usuário (Rosa - Cor 218)
    let user = std::env::var("USER").unwrap_or("clios".to_string());
    segments.push(PowerlineSegment {
        text: format!("🐧 {}", user),
        bg: "218".to_string(), // Rosa pastel
        fg: "0".to_string(),   // Preto
    });

    // 2. Diretório Atual (Laranja - Cor 215)
    if let Ok(path) = std::env::current_dir() {
        let path_str = path.display().to_string();
        // Truque para encurtar o home
        let home = std::env::var("HOME").unwrap_or_default();
        let short_path = path_str.replace(&home, "~");

        segments.push(PowerlineSegment {
            text: short_path,
            bg: "215".to_string(), // Laranja
            fg: "0".to_string(),
        });
    }

    // 3. Git Branch (Amarelo - Cor 229)
    if let Some(branch) = get_git_branch() {
        segments.push(PowerlineSegment {
            text: format!(" {}", branch), // Ícone de branch
            bg: "229".to_string(),         // Amarelo claro
            fg: "0".to_string(),
        });
    }

    // 4. Contexto de Linguagem (Verde - Cor 150)
    struct LangRule {
        file: &'static str,
        icon: &'static str,
        color: String,
        get_ver: fn() -> Option<String>,
    }

    let languages = [
        LangRule {
            file: "Cargo.toml",
            icon: "",
            color: "150".to_string(),
            get_ver: get_rust_version,
        },
        LangRule {
            file: "package.json",
            icon: "⬢",
            color: "150".to_string(),
            get_ver: get_node_version,
        },
        LangRule {
            file: "pyproject.toml",
            icon: "",
            color: "220".to_string(),
            get_ver: get_python_version,
        },
    ];

    let mut found_lang = false;
    for lang in languages.iter() {
        if std::path::Path::new(lang.file).exists() {
            let version = (lang.get_ver)().unwrap_or_else(|| "".to_string());

            segments.push(PowerlineSegment {
                text: format!("{} {}", lang.icon, version).trim().to_string(),
                bg: lang.color.clone(),
                fg: "0".to_string(),
            });
            found_lang = true;
            break;
        }
    }

    // Se não achou pyproject.toml mas tem arquivos python soltos
    if !found_lang
        && (std::path::Path::new("requirements.txt").exists()
            || std::path::Path::new("main.py").exists())
    {
        segments.push(PowerlineSegment {
            text: "🐍 Py".to_string(),
            bg: "220".to_string(),
            fg: "0".to_string(),
        });
    }

    // 5. Relógio (Azul - Cor 117)
    let time = Local::now().format("%H:%M").to_string();
    segments.push(PowerlineSegment {
        text: format!("🕑 {}", time),
        bg: "117".to_string(),
        fg: "0".to_string(),
    });

    segments
}


// ============================================================================
// FILE: src/config.rs
// ============================================================================
//! # Configuration Module
//!
//! Handles loading and parsing of the `~/.clios.toml` configuration file.
//! Also defines all configuration structures used throughout the shell.

use serde::Deserialize;
use std::env;
use std::path::Path;

// -----------------------------------------------------------------------------
// PROMPT CONFIGURATION
// -----------------------------------------------------------------------------

/// Configurações visuais do Prompt de comando.
///
/// Esta estrutura mapeia a seção `[prompt]` do arquivo de configuração `.clios.toml`.
/// Permite que o usuário personalize cores, símbolos e informações exibidas.
#[derive(Debug, Deserialize, Clone)]
pub struct ConfigPrompt {
    /// O símbolo exibido no final do prompt (ex: `>`, `$`, `➜`, ``).
    /// * Padrão: `>`
    pub symbol: Option<String>,

    /// A cor do símbolo e do separador.
    /// * Valores aceitos: "red", "green", "blue", "purple", "cyan", "yellow".
    /// * Padrão: "blue"
    pub color: Option<String>,

    /// Cor do caminho (/mnt/c/...)
    pub path_color: Option<String>,

    /// Cor do símbolo (setinha >)
    pub symbol_color: Option<String>,

    /// Define se deve mostrar a branch atual do Git.
    /// * Padrão: `true`
    pub show_git: Option<bool>,
}

// -----------------------------------------------------------------------------
// HISTORY CONFIGURATION
// -----------------------------------------------------------------------------

/// Configurações do histórico de comandos.
///
/// Esta estrutura mapeia a seção `[history]` do arquivo `.clios.toml`.
#[derive(Debug, Deserialize, Clone)]
pub struct ConfigHistory {
    /// Nome do arquivo onde o histórico será salvo na pasta HOME.
    /// * Padrão: `.clios_history`
    pub file: Option<String>,

    /// Número máximo de comandos a serem lembrados.
    /// * Padrão: `1000`
    pub max_entries: Option<usize>,
}

// -----------------------------------------------------------------------------
// SYNTAX HIGHLIGHTING CONFIGURATION
// -----------------------------------------------------------------------------

/// Configurações de cores para o realce de sintaxe (Syntax Highlighting).
///
/// Mapeia a seção `[syntax]` do arquivo `.clios.toml`.
/// Define as cores usadas enquanto o usuário digita um comando.
#[derive(Debug, Deserialize, Clone)]
pub struct ConfigSyntax {
    /// Cor para comandos válidos (encontrados no sistema ou builtins).
    /// * Padrão: "green"
    pub valid_cmd: Option<String>,

    /// Cor para comandos inválidos (não encontrados).
    /// * Padrão: "red"
    pub invalid_cmd: Option<String>,
}

// -----------------------------------------------------------------------------
// VERSION READING STRUCTURES
// -----------------------------------------------------------------------------

/// Struct para ler Cargo.toml
#[derive(Deserialize)]
pub struct CargoToml {
    pub package: CargoPackage,
}

#[derive(Deserialize)]
pub struct CargoPackage {
    pub version: String,
}

/// Struct para ler package.json
#[derive(Deserialize)]
pub struct PackageJson {
    pub version: String,
}

/// Struct para ler pyproject.toml
#[derive(Deserialize)]
pub struct PyProjectToml {
    pub project: Option<PyProjectSection>,
    pub tool: Option<PyToolSection>,
}

#[derive(Deserialize)]
pub struct PyProjectSection {
    pub version: Option<String>,
}

#[derive(Deserialize)]
pub struct PyToolSection {
    pub poetry: Option<PyPoetrySection>,
}

#[derive(Deserialize)]
pub struct PyPoetrySection {
    pub version: Option<String>,
}

// -----------------------------------------------------------------------------
// ROOT CONFIGURATION
// -----------------------------------------------------------------------------

/// A Configuração Raiz (Root) da Clios Shell.
///
/// Esta é a estrutura principal que representa o arquivo `~/.clios.toml` inteiro.
/// O `serde` lê o arquivo e preenche estes campos automaticamente.
///
/// # Exemplo de Arquivo `.clios.toml`
/// ```toml
/// [prompt]
/// symbol = "➜"
/// color = "purple"
///
/// [history]
/// max_entries = 5000
/// ```
#[derive(Debug, Deserialize, Clone)]
pub struct CliosConfig {
    /// Configurações da seção `[prompt]`.
    pub prompt: Option<ConfigPrompt>,

    /// Configurações da seção `[history]`.
    pub history: Option<ConfigHistory>,

    /// Configurações da seção `[syntax]`.
    pub syntax: Option<ConfigSyntax>,

    /// Tema do prompt (powerline ou classic).
    pub theme: Option<String>,
}

impl CliosConfig {
    /// Retorna a configuração padrão (Default) caso o arquivo não exista.
    ///
    /// # Valores Padrão
    /// * **Prompt:** Símbolo `> `, Cor `blue`, Git `true`.
    /// * **History:** Arquivo `.clios_history`, 1000 entradas.
    pub fn default() -> Self {
        Self {
            prompt: Some(ConfigPrompt {
                symbol: Some("> ".to_string()),
                color: Some("blue".to_string()),
                show_git: Some(true),
                path_color: None,
                symbol_color: None,
            }),
            history: Some(ConfigHistory {
                file: Some(".clios_history".to_string()),
                max_entries: Some(1000),
            }),
            syntax: Some(ConfigSyntax {
                valid_cmd: Some("green".to_string()),
                invalid_cmd: Some("red".to_string()),
            }),
            theme: Some("powerline".to_string()),
        }
    }
}

// -----------------------------------------------------------------------------
// LOADING FUNCTIONS
// -----------------------------------------------------------------------------

/// Carrega a configuração do usuário a partir de um arquivo TOML.
///
/// # Estratégia de Carregamento
/// 1. Busca pela variável de ambiente `$HOME`.
/// 2. Tenta abrir o arquivo `$HOME/.clios.toml`.
/// 3. Se o arquivo existir e for válido, retorna a `CliosConfig` preenchida.
/// 4. Se o arquivo não existir ou tiver erros de sintaxe, retorna `CliosConfig::default()`
///    e imprime um aviso no stderr (se for erro de sintaxe).
pub fn load_toml_config() -> CliosConfig {
    // 1. Constrói o caminho ~/.clios.toml
    let config_path = env::var("HOME")
        .map(|p| Path::new(&p).join(".clios.toml"))
        .unwrap_or_else(|_| Path::new(".clios.toml").to_path_buf());

    // 2. Tenta ler e fazer o parse
    if config_path.exists()
        && let Ok(contents) = std::fs::read_to_string(&config_path) {
            match toml::from_str::<CliosConfig>(&contents) {
                Ok(cfg) => return cfg, // Sucesso!
                Err(e) => {
                    eprintln!(
                        "\x1b[1;33m[AVISO CONFIG]\x1b[0m Erro no .clios.toml: {}",
                        e
                    );
                    eprintln!("--> Usando configuração padrão.");
                }
            }
        }

    // 3. Fallback para padrão
    CliosConfig::default()
}

/// Converte um nome de cor legível (ex: "red") para seu código ANSI correspondente.
///
/// Esta função é usada para traduzir as configurações do usuário no arquivo TOML
/// para os caracteres de escape que o terminal entende.
///
/// # Cores Suportadas
/// * red, green, yellow, blue, purple, cyan, white.
/// * Qualquer outra string retorna o código de reset/padrão.
pub fn get_color_ansi(color_name: &str) -> String {
    match color_name {
        "red" => "\x1b[31m".to_string(),
        "green" => "\x1b[32m".to_string(),
        "yellow" => "\x1b[33m".to_string(),
        "blue" => "\x1b[34m".to_string(),
        "purple" => "\x1b[35m".to_string(),
        "cyan" => "\x1b[36m".to_string(),
        "white" => "\x1b[37m".to_string(),
        _ => "\x1b[0m".to_string(), // Default (sem cor)
    }
}


// ============================================================================
// FILE: src/completion.rs
// ============================================================================
//! # Completion Module
//!
//! Provides autocomplete and syntax highlighting for the shell using rustyline.

use rustyline::completion::{Completer, Pair};
use rustyline::highlight::{CmdKind, Highlighter};
use rustyline::hint::HistoryHinter;
use rustyline::Context;
use rustyline::{Helper, Hinter, Validator};
use std::borrow::Cow;
use std::collections::HashMap;
use std::env;
use std::fs;
use std::sync::{Arc, RwLock};
use which::which;

// -----------------------------------------------------------------------------
// CLIOS HELPER
// -----------------------------------------------------------------------------

/// # CliosHelper (O Cérebro Visual)
///
/// Esta estrutura é exigida pelo `rustyline` para gerenciar a interação com o usuário.
/// Ela agrupa todas as funcionalidades de "UX" (User Experience) do terminal.
///
/// ## Funcionalidades:
/// * **Completer:** Autocomplete de arquivos e comandos quando aperta TAB.
/// * **Hinter:** Sugestão cinza baseada no histórico.
/// * **Highlighter:** Colore o comando enquanto você digita (Verde/Vermelho).
#[derive(Helper, Hinter, Validator)]
pub struct CliosHelper {
    /// O sugestor baseado no histórico (HistoryHinter).
    #[rustyline(Hinter)]
    pub hinter: HistoryHinter,

    /// Armazena a versão colorida do prompt (com códigos ANSI).
    #[rustyline(Ignore)]
    pub colored_prompt: String,

    /// Cor para comandos válidos.
    #[rustyline(Ignore)]
    pub color_valid: String,

    /// Cor para comandos inválidos.
    #[rustyline(Ignore)]
    pub color_invalid: String,
    
    /// Mapa de aliases para autocomplete (compartilhado com a shell)
    #[rustyline(Ignore)]
    pub aliases: Arc<RwLock<HashMap<String, String>>>,
}

impl CliosHelper {
    /// Creates a new CliosHelper with the given colors.
    pub fn new(color_valid: String, color_invalid: String) -> Self {
        Self {
            hinter: HistoryHinter {},
            colored_prompt: String::new(),
            color_valid,
            color_invalid,
            aliases: Arc::new(RwLock::new(HashMap::new())),
        }
    }
    
    /// Atualiza os aliases disponíveis para autocomplete
    #[allow(dead_code)]
    pub fn set_aliases(&mut self, aliases: HashMap<String, String>) {
        if let Ok(mut lock) = self.aliases.write() {
            *lock = aliases;
        }
    }
}

// -----------------------------------------------------------------------------
// HIGHLIGHTER IMPLEMENTATION
// -----------------------------------------------------------------------------

impl Highlighter for CliosHelper {
    fn highlight_prompt<'b, 's: 'b, 'p: 'b>(
        &'s self,
        prompt: &'p str,
        default: bool,
    ) -> Cow<'b, str> {
        if default {
            Cow::Borrowed(&self.colored_prompt)
        } else {
            Cow::Borrowed(prompt)
        }
    }

    fn highlight<'l>(&self, line: &'l str, _pos: usize) -> Cow<'l, str> {
        let input = line.trim();
        if input.is_empty() {
            return Cow::Borrowed(line);
        }
        let first_word = input.split_whitespace().next().unwrap_or("");

        let is_valid = matches!(
            first_word,
            "cd" | "exit" | "pwd" | "alias" | "rhai" | "fg" | "export" | "history" | "source" | "load" | "plugins"
        ) || which(first_word).is_ok();

        if is_valid {
            Cow::Owned(format!("{}{}\x1b[0m", self.color_valid, line))
        } else {
            Cow::Owned(format!("{}{}\x1b[0m", self.color_invalid, line))
        }
    }

    fn highlight_char(&self, _line: &str, _pos: usize, _forced: CmdKind) -> bool {
        true
    }
}

// -----------------------------------------------------------------------------
// COMPLETER IMPLEMENTATION
// -----------------------------------------------------------------------------

/// Lista de builtins para autocomplete
const BUILTINS: &[&str] = &[
    "cd", "pwd", "alias", "unalias", "export", "unset", "history",
    "source", "load", "plugins", "rhai", "fg", "jobs", "type", "help", "version", "exit",
];

impl Completer for CliosHelper {
    type Candidate = Pair;

    fn complete(
        &self,
        line: &str,
        pos: usize,
        _ctx: &Context,
    ) -> rustyline::Result<(usize, Vec<Pair>)> {
        let (start, word_to_complete) = extract_word(line, pos);
        let mut matches = Vec::new();
        
        // Verifica se é a primeira palavra (comando)
        let is_first_word = !line[..start].chars().any(|c| !c.is_whitespace());

        if is_first_word {
            // Autocomplete de comandos: builtins, aliases, e PATH
            let prefix_lower = word_to_complete.to_lowercase();
            
            // 1. Builtins
            for builtin in BUILTINS {
                if builtin.to_lowercase().starts_with(&prefix_lower) {
                    matches.push(Pair {
                        display: builtin.to_string(),
                        replacement: builtin.to_string(),
                    });
                }
            }
            
            // 2. Aliases
            if let Ok(aliases) = self.aliases.read() {
                for alias_name in aliases.keys() {
                    if alias_name.to_lowercase().starts_with(&prefix_lower) {
                        matches.push(Pair {
                            display: format!("{} (alias)", alias_name),
                            replacement: alias_name.clone(),
                        });
                    }
                }
            }
            
            // 3. Comandos do PATH
            if let Ok(path_var) = env::var("PATH") {
                for path_dir in path_var.split(':') {
                    if let Ok(entries) = fs::read_dir(path_dir) {
                        for entry in entries.flatten() {
                            if let Ok(name) = entry.file_name().into_string() {
                                if name.to_lowercase().starts_with(&prefix_lower) {
                                    // Evita duplicatas
                                    if !matches.iter().any(|p| p.replacement == name) {
                                        matches.push(Pair {
                                            display: name.clone(),
                                            replacement: name,
                                        });
                                    }
                                }
                            }
                        }
                    }
                }
            }
        } else {
            // Autocomplete de arquivos (comportamento original)
            let (dir, file_prefix) = if let Some(idx) = word_to_complete.rfind('/') {
                (&word_to_complete[..idx + 1], &word_to_complete[idx + 1..])
            } else {
                ("", word_to_complete)
            };

            let dir_path = if dir.is_empty() {
                ".".to_string()
            } else {
                dir.to_string()
            };

            if let Ok(entries) = fs::read_dir(&dir_path) {
                for entry in entries.flatten() {
                    if let Ok(name) = entry.file_name().into_string() {
                        if name.to_lowercase().starts_with(&file_prefix.to_lowercase()) {
                            let replacement = format!("{}{}", dir, name);
                            matches.push(Pair {
                                display: name,
                                replacement,
                            });
                        }
                    }
                }
            }
        }

        Ok((start, matches))
    }
}

// -----------------------------------------------------------------------------
// HELPER FUNCTIONS
// -----------------------------------------------------------------------------

/// Função auxiliar para pegar a palavra que está sendo digitada (separa por espaços)
fn extract_word(line: &str, pos: usize) -> (usize, &str) {
    let line_before_cursor = &line[..pos];
    if let Some(last_space) = line_before_cursor.rfind(char::is_whitespace) {
        (last_space + 1, &line_before_cursor[last_space + 1..])
    } else {
        (0, line_before_cursor)
    }
}


// ============================================================================
// FILE: src/rhai_integration.rs
// ============================================================================
//! # Rhai Integration Module
//!
//! Handles the Rhai scripting engine setup, including all registered functions
//! and script execution.

use rhai::{Engine, EvalAltResult, Scope, AST};

// -----------------------------------------------------------------------------
// ENGINE CREATION
// -----------------------------------------------------------------------------

/// Creates and configures a new Rhai engine with all shell functions registered.
pub fn create_rhai_engine() -> Engine {
    let mut engine = Engine::new();

    // --- shell_exec function ---
    engine.register_fn("shell_exec", |cmd_str: &str| -> rhai::Map {
        let parts: Vec<&str> = cmd_str.split_whitespace().collect();
        let mut map = rhai::Map::new();

        if parts.is_empty() {
            map.insert("success".into(), false.into());
            return map;
        }

        match std::process::Command::new(parts[0])
            .args(&parts[1..])
            .output()
        {
            Ok(output) => {
                let stdout = String::from_utf8_lossy(&output.stdout).trim().to_string();
                let stderr = String::from_utf8_lossy(&output.stderr).trim().to_string();
                let combined = format!("{}{}", stdout, stderr).trim().to_string();

                map.insert("success".into(), output.status.success().into());
                map.insert("output".into(), combined.into());
                map
            }
            Err(e) => {
                map.insert("success".into(), false.into());
                map.insert("output".into(), e.to_string().into());
                map
            }
        }
    });

    // --- confirm function (UI Widget) ---
    engine.register_fn("confirm", |prompt: &str| -> bool {
        match inquire::Confirm::new(prompt).with_default(false).prompt() {
            Ok(true) => true,
            Ok(false) => false,
            Err(_) => false,
        }
    });

    // --- select function (UI Widget) ---
    engine.register_fn(
        "select",
        |prompt: &str, options: Vec<rhai::Dynamic>| -> String {
            let items: Vec<String> = options.iter().map(|item| item.to_string()).collect();

            inquire::Select::new(prompt, items).prompt().unwrap_or_default()
        },
    );

    // --- input function ---
    engine.register_fn("input", |prompt: &str| -> String {
        use std::io::{self, Write};
        print!("{}", prompt);
        let _ = io::stdout().flush();

        let mut buffer = String::new();
        let _ = io::stdin().read_line(&mut buffer);
        buffer.trim().to_string()
    });

    // --- http_get function ---
    engine.register_fn("http_get", |url: &str| -> String {
        match reqwest::blocking::get(url) {
            Ok(resp) => {
                if resp.status().is_success() {
                    resp.text()
                        .unwrap_or_else(|_| "Erro: Corpo vazio".to_string())
                } else {
                    format!("Erro HTTP: {}", resp.status())
                }
            }
            Err(e) => format!("Erro de Conexão: {}", e),
        }
    });

    // --- save_file function ---
    engine.register_fn("save_file", |path: &str, content: &str| -> bool {
        if let Some(parent) = std::path::Path::new(path).parent() {
            let _ = std::fs::create_dir_all(parent);
        }
        std::fs::write(path, content).is_ok()
    });

    engine
}

// -----------------------------------------------------------------------------
// SCRIPT EXECUTION
// -----------------------------------------------------------------------------

/// Inicializa e executa um script Rhai externo (.rhai).
///
/// Diferente do modo interativo, esta função cria um motor "limpo" e novo.
/// Isso garante que scripts rodem em um ambiente isolado.
pub fn run_rhai_script(path: &str) -> Result<(), Box<EvalAltResult>> {
    let mut engine = Engine::new();

    engine.register_fn("shell_exec", |cmd_str: &str| -> rhai::Map {
        let parts: Vec<&str> = cmd_str.split_whitespace().collect();
        let mut map = rhai::Map::new();

        if parts.is_empty() {
            map.insert("success".into(), false.into());
            return map;
        }

        match std::process::Command::new(parts[0])
            .args(&parts[1..])
            .output()
        {
            Ok(output) => {
                let stdout = String::from_utf8_lossy(&output.stdout).trim().to_string();
                let stderr = String::from_utf8_lossy(&output.stderr).trim().to_string();
                let combined = format!("{}{}", stdout, stderr).trim().to_string();

                map.insert("success".into(), output.status.success().into());
                map.insert("output".into(), combined.into());
                map
            }
            Err(e) => {
                map.insert("success".into(), false.into());
                map.insert("output".into(), e.to_string().into());
                map
            }
        }
    });

    engine.register_fn("input", |prompt: &str| -> String {
        use std::io::{self, Write};
        print!("{}", prompt);
        let _ = io::stdout().flush();

        let mut buffer = String::new();
        let _ = io::stdin().read_line(&mut buffer);
        buffer.trim().to_string()
    });

    engine.run_file(path.into())?;

    Ok(())
}

// -----------------------------------------------------------------------------
// PLUGIN MANAGEMENT
// -----------------------------------------------------------------------------

/// Tenta executar uma função do Plugin carregado.
/// Retorna `true` se a função existia e foi executada.
pub fn try_execute_plugin_function(
    engine: &Engine,
    scope: &mut Scope,
    ast: &AST,
    cmd: &str,
    args: Vec<String>,
) -> bool {
    let function_exists = ast.iter_functions().any(|f| f.name == cmd);

    if function_exists {
        let rhai_args: Vec<rhai::Dynamic> =
            args.into_iter().map(rhai::Dynamic::from).collect();

        let result = engine.call_fn::<rhai::Dynamic>(scope, ast, cmd, (rhai_args,));

        match result {
            Ok(_) => return true,
            Err(e) => println!("Erro no Plugin (Função {}): {}", cmd, e),
        }
        return true;
    }
    false
}


// ============================================================================
// FILE: src/tests.rs
// ============================================================================
//! Testes Unitários para Clios Shell
//! 
//! Execute com: cargo test

#[cfg(test)]
mod tests {
    // =========================================================================
    // TESTES DE EXPANSÃO
    // =========================================================================

    #[test]
    fn test_expand_variables_simple() {
        use std::env;
        unsafe {
            env::set_var("TEST_VAR", "hello");
        }
        
        let tokens = vec!["$TEST_VAR".to_string()];
        let result = crate::expansion::expand_variables(tokens);
        
        assert_eq!(result, vec!["hello"]);
    }

    #[test]
    fn test_expand_variables_with_braces() {
        use std::env;
        unsafe {
            env::set_var("TEST_VAR", "hello");
        }
        
        let tokens = vec!["${TEST_VAR}".to_string()];
        let result = crate::expansion::expand_variables(tokens);
        
        assert_eq!(result, vec!["hello"]);
    }

    #[test]
    fn test_expand_variables_in_string() {
        use std::env;
        unsafe {
            env::set_var("TESTUSER", "myname");
        }
        
        let tokens = vec!["prefix-$TESTUSER-suffix".to_string()];
        let result = crate::expansion::expand_variables(tokens);
        
        assert!(result[0].contains("myname"), "Expected result to contain 'myname', got: {}", result[0]);
    }

    #[test]
    fn test_expand_tilde() {
        use std::env;
        let home = env::var("HOME").unwrap_or_else(|_| "/home/user".to_string());
        
        let tokens = vec!["~".to_string()];
        let result = crate::expansion::expand_tilde(tokens);
        
        assert_eq!(result[0], home);
    }

    #[test]
    fn test_expand_tilde_with_path() {
        use std::env;
        let home = env::var("HOME").unwrap_or_else(|_| "/home/user".to_string());
        
        let tokens = vec!["~/Documents".to_string()];
        let result = crate::expansion::expand_tilde(tokens);
        
        assert_eq!(result[0], format!("{}/Documents", home));
    }

    #[test]
    fn test_split_logical_and_simple() {
        let input = "echo hello && echo world";
        let result = crate::expansion::split_logical_and(input);
        
        assert_eq!(result.len(), 2);
        assert_eq!(result[0].trim(), "echo hello");
        assert_eq!(result[1].trim(), "echo world");
    }

    #[test]
    fn test_split_logical_and_with_quotes() {
        let input = r#"echo "a && b" && echo test"#;
        let result = crate::expansion::split_logical_and(input);
        
        assert_eq!(result.len(), 2);
        assert!(result[0].contains("a && b"));
    }

    #[test]
    fn test_split_logical_and_no_split() {
        let input = r#"echo "test && test2""#;
        let result = crate::expansion::split_logical_and(input);
        
        assert_eq!(result.len(), 1);
    }

    #[test]
    fn test_expand_alias_simple() {
        use std::collections::HashMap;
        let mut aliases = HashMap::new();
        aliases.insert("ll".to_string(), "ls -la".to_string());
        
        let input = "ll /tmp";
        let result = crate::expansion::expand_alias_string(input, &aliases);
        
        assert_eq!(result, "ls -la /tmp");
    }

    #[test]
    fn test_expand_alias_no_match() {
        use std::collections::HashMap;
        let aliases = HashMap::new();
        
        let input = "ls -la";
        let result = crate::expansion::expand_alias_string(input, &aliases);
        
        assert_eq!(result, "ls -la");
    }

    // =========================================================================
    // TESTES DE PIPELINE
    // =========================================================================

    #[test]
    fn test_parse_redirection_stdout() {
        let tokens = vec![
            "echo".to_string(),
            "test".to_string(),
            ">".to_string(),
            "/tmp/test_output.txt".to_string()
        ];
        
        let (clean, stdin_file, stdout_file, stderr_file) = crate::pipeline::parse_redirection(&tokens);
        
        assert_eq!(clean, vec!["echo", "test"]);
        assert!(stdin_file.is_none());
        assert!(stdout_file.is_some());
        assert!(stderr_file.is_none());
    }

    #[test]
    fn test_parse_redirection_stderr() {
        let tokens = vec![
            "ls".to_string(),
            "/nonexistent".to_string(),
            "2>".to_string(),
            "/tmp/test_error.txt".to_string()
        ];
        
        let (clean, stdin_file, stdout_file, stderr_file) = crate::pipeline::parse_redirection(&tokens);
        
        assert_eq!(clean, vec!["ls", "/nonexistent"]);
        assert!(stdin_file.is_none());
        assert!(stdout_file.is_none());
        assert!(stderr_file.is_some());
    }

    #[test]
    fn test_parse_redirection_both() {
        let tokens = vec![
            "ls".to_string(),
            "/tmp".to_string(),
            ">".to_string(),
            "/tmp/out.txt".to_string(),
            "2>".to_string(),
            "/tmp/err.txt".to_string()
        ];
        
        let (clean, stdin_file, stdout_file, stderr_file) = crate::pipeline::parse_redirection(&tokens);
        
        assert_eq!(clean, vec!["ls", "/tmp"]);
        assert!(stdin_file.is_none());
        assert!(stdout_file.is_some());
        assert!(stderr_file.is_some());
    }

    // =========================================================================
    // TESTES DE SHELL
    // =========================================================================

    #[test]
    fn test_shell_creation() {
        use crate::config::CliosConfig;
        let config = CliosConfig::default();
        let shell = crate::shell::CliosShell::new(config);
        
        assert_eq!(shell.last_exit_code, 0);
        assert!(shell.aliases.is_empty());
        assert!(shell.previous_dir.is_none());
    }

    // =========================================================================
    // TESTES DE SUBSHELLS
    // =========================================================================

    #[test]
    fn test_expand_subshells_simple() {
        let input = "echo $(echo test)";
        let result = crate::expansion::expand_subshells(input);
        
        // O resultado deve conter "test" expandido
        assert!(result.contains("test"));
    }

    #[test]
    fn test_expand_subshells_empty() {
        let input = "echo $()";
        let result = crate::expansion::expand_subshells(input);
        
        // Deve processar sem travar
        assert!(result.contains("echo"));
    }

    #[test]
    fn test_expand_subshells_unclosed() {
        let input = "echo $(echo test";
        let result = crate::expansion::expand_subshells(input);
        
        // Deve retornar algo sem travar
        assert!(result.contains("echo"));
    }

    // =========================================================================
    // TESTES DE PROTEÇÃO CONTRA RECURSÃO
    // =========================================================================

    #[test]
    fn test_alias_recursive_protection() {
        use std::collections::HashMap;
        let mut aliases = HashMap::new();
        // Alias que se refere a si mesmo
        aliases.insert("ls".to_string(), "ls -la".to_string());
        
        let input = "ls";
        let result = crate::expansion::expand_alias_string(input, &aliases);
        
        // Deve detectar recursão e retornar original
        assert_eq!(result, "ls");
    }

    #[test]
    fn test_alias_deep_recursion() {
        use std::collections::HashMap;
        let mut aliases = HashMap::new();
        aliases.insert("a".to_string(), "b".to_string());
        aliases.insert("b".to_string(), "c".to_string());
        aliases.insert("c".to_string(), "d".to_string());
        // ... muitos níveis
        
        let input = "a";
        let result = crate::expansion::expand_alias_string(input, &aliases);
        
        // Deve parar antes de overflow
        assert!(!result.is_empty());
    }
}

// ============================================================================
// END OF COMPLETE CODE
// ============================================================================
